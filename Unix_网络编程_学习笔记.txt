Unix网络编程 卷1

第1章 简介

    网络应用系统主要构成有两部分：客户端(client)和服务器(server)。
        举例来说：web服务器程序是一个长时间运行的守护进程，web客户与服务器之间使用TCP通信，TCP转而使用IP通信，IP通过以太网驱动程序的数据链路层通信。
        应用层构架
    客户端和服务器通常是用户进程，而TCP和IP协议通常是内核中"协议栈"的一部分。
    网络：
        分类
            LAN：局域网(内网)
            WAN：广域网(外网)
        路由器是广域网的架构设备。当下最大的广域网是因特网internet。
        网络架构
    时间获取客户程序server
    Code

    /* 一个简单的时间获取客户程序server */
    #include <time.h>
    #include "unp.h"
     
    #define MAXLINE 4096
    #define LISTENQ 1024
    //#define SA struct sockaddr
    typedef struct sockaddr SA;
     
    int
    main(int argc, char **argv)
    {
    	int listenfd, connfd;
    	struct sockaddr_in servaddr;
    	char buff[MAXLINE];
    	time_t ticks;
     	// 使用socket创建一个网际(AF_INET)字节流(SOCK_STEREAM)套接字,
     	// 返回类型为整数类型描述符, 后面的函数调用(如 connect, read等)就使用该描述符来标识此套接字
    	listenfd = socket(AF_INET, SOCK_STREAM, 0);
     
    	bzero(&servaddr, sizeof(servaddr));
    	servaddr.sin_family      = AF_INET;
    	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    	servaddr.sin_port        = htons(1300);	/* daytime server */
     
    	bind(listenfd, (SA *) &servaddr, sizeof(servaddr));
     	// 调用listen函数将套接字转换为监控套接字
    	listen(listenfd, LISTENQ);
     	// 接受服务器链接,发送应答
    	for ( ; ; ) {
    	    connfd = accept(listenfd, (SA *) NULL, NULL);
     
                ticks = time(NULL);
                snprintf(buff, sizeof(buff), "%.24s\r\n", ctime(&ticks));
                write(connfd, buff, strlen(buff));
     
    	    close(connfd);
    	}
    }
     
    /* 一个简单的时间获取客户程序client */
    #include	"unp.h"
     
    #define MAXLINE 1024
    //#define SA struct sockaddr
    typedef struct sockaddr SA;
     
    int main(int argc, char **argv)
    {
    	int sockfd, n;
    	char recvline[MAXLINE + 1];
    	struct sockaddr_in servaddr;
     
    	if (argc != 2) {
    		printf ("usage: %s <IPaddress>\n", argv[0]);
	}
     	// 使用socket创建一个网际(AF_INET)字节流(SOCK_STEREAM)套接字,
     	// 返回类型为整数类型描述符, 后面的函数调用(如 connect, read等)就使用该描述符来标识此套接字
    	if ( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    		printf ("socket error\n");
     	// 把IP和Port填入一个网际套接字地址结构(名为 servaddr和sockaddr_in的结构变量)
     	// 1. 使用bzero将结构体清空
    	bzero(&servaddr, sizeof(servaddr));
    	servaddr.sin_family = AF_INET; // 2. 置地址族为 AF_INET
    	servaddr.sin_port   = htons(1300);	/* daytime server */ // 3. 置位端口
    	if (inet_pton(AF_INET, argv[1], &servaddr.sin_addr) <= 0) // 4. 置位IP
    		printf ("inet_pton error for %s\n", argv[1]);
     	// 建立和服务器的链接
    	if (connect(sockfd, (SA *) &servaddr, sizeof(servaddr)) < 0)
    		printf ("connect error\n");
     	/// 读入并输出服务器应答 
     	// 使用read函数读取服务器应答,使用标准输出 fputs输出结构
    	while ( (n = read(sockfd, recvline, MAXLINE)) > 0) { 
    		recvline[n] = 0;	/* null terminate */
    		if (fputs(recvline, stdout) == EOF)
    			printf ("fputs error\n");
    	}
    	if (n < 0)
    		printf ("read error\n");
     
    	exit(0);
    }
     
    /* unp.h */
    #ifndef __UNP_H__
    #define __UNP_H__
     
    #include	<sys/types.h>	/* basic system data types */
    #include	<sys/socket.h>	/* basic socket definitions */
    #include	<sys/time.h>	/* timeval{} for select() */
    #include	<time.h>		/* timespec{} for pselect() */
    #include	<netinet/in.h>	/* sockaddr_in{} and other Internet defns */
    #include	<arpa/inet.h>	/* inet(3) functions */
    #include	<errno.h>
    #include	<fcntl.h>		/* for nonblocking */
    #include	<netdb.h>
    #include	<signal.h>
    #include	<stdio.h>
    #include	<stdlib.h>
    #include	<string.h>
    #include	<sys/stat.h>	/* for S_xxx file mode constants */
    #include	<sys/uio.h>		/* for iovec{} and readv/writev */
    #include	<unistd.h>
    #include	<sys/wait.h>
    #include	<sys/un.h>		/* for Unix domain sockets */
     
    #endif //__UNP_H__

        一些 Tricks:
            调用sprintf无法检查目的缓冲区是否溢出，相反，snprintf要求其第二个参数指定目的缓冲区的大小，因此可以确保该缓冲区不溢出。
            许多网络入侵是由黑客通过发送数据，导致服务器对sprintf的调用使其缓冲区溢出而发生的，必须小心使用的函数还有gets/strcat/strcpy，通常应分别改为调用fgets/strncat/strncpy。

    OSI模型 open systems interconnection(全称：计算机通信开放系统互连模型。)
        分层:
            物理层/数据链路层：主要是设备驱动和网络硬件。
            网络层：由IPv4和IPv6这两个协议处理。
            传输层：即本书所讲的套接字编程接口。
            应用层/会话层/表示层：统称为应用层，如web客户端(浏览器)、telnet客户端、web服务器、FTP服务器等。

第2章 传输层TCP-UDP-SCTP

    协议类型:
        TCP：传输控制协议，面向连接，全双工字节流。流套接字。关心：确认、超时、重传等细节。
        UDP：用户数据报协议，无连接协议。数据报套接字。不保证最终达到目的地。
        ICMP：网际控制消息协议，处理路由器和主机之间流通的错误和控制消息。
        ARP：地址解析协议，把IPv4地址映射成一个硬件地址。
        RARP：反地址解析协议，把一个硬件地址映射成一个IPv4地址。

    TIME_WAIT状态有两个存在的理由：
        可靠地实现TCP全双工连接的终止；
        允许老的重复分节在网络中消逝。

    端口号port：
        传输层协议都使用16位整数的端口号来区分不同的进程。
        0~ 1023(自控保留) | 1024~ 49151(已登记) |49152~ 65535(动态私有)

    通讯对socket pair：
        每个TCP分节中都有16bit的端口号和32bit的IPv4地址。

第3章 套接字编程简介

        几乎每一个例子都用到了套接字地址结构. 这些结构可以在两个方向上传递: 从 进程到内核 和 内核到进程 .
        地址转换函数在地址的文本表达 和他们存放在套接字地址结构中的二进制之间进行转换
            inet_addr/inet_ntoa 适用于IPv4
            inet_pton/inet_ntop 适用于IPv4/IPv6

套接字的地址结构

IPv4 socket 地址：struct sockaddr_in
一个IPv4 socket 地址会被存储在一个 sockaddr_in 结构中，该结构在<netinet/in.h>中进行定义，具体如下。
struct in_addr
{
	in_addr_t	s_addr;
};
struct sockaddr_in
{
	sa_family_t	sin_family;
	in_port_t	sin_port;
	struct in_addr	sin_addr;
	...
};
普通的 sockaddr 结构中有一个字段来标识 socket domain，该字段对应于 sockaddr_in 结构中的 sin_family 字段，其值总为 AF_INET。
sin_port 和 sin_addr 字段是端口号和 IP 地址，它们都是网络字节序的。in_port_t 和 in_addr_t 数据类型是无符号整型，其长度分别为 16 位和 32 位。

IPv6 socket 地址：struct sockaddr_in6
与 IPv4 地址一样，一个 IPv6 socket 地址包含一个 IP 地址和一个端口号，它们之间的差别在于IPv6 地址是 128 位而不是 32 位的。
一个 IPv6 socket 地址会被存储在一个 sockaddr_in6 结构中，该结构在<netinet/in.h>中进行定义，具体如下。
struct in6_addr
{
	uint8_t	s6_addr[16];
};
struct sockaddr_in6
{
	sa_family_t	sin6_family;
	in_port_t	sin6_port;
	uint32_t		sin6_flowinfo;
	struct in6_addr	sin6_addr;
	uint32_t		sin6_scope_id;
};

    通用套接字地址结构: sockaddr
        套接字函数被定义为以指向某个通用套接字地址结构的指针作为其参数之一,例如bind函数
            int bind(int, struct sockaddr*, socklen_t) // 注意第二个参数为通用套接字地址结构
            调用这些函数时都必须把指向特定协议的套接字地址结构的指针强转为指向通用套接字地址结构的指针.
                如:bind(sockfd, (struct sockaddr*) &serv, sizeif(serv));
        这个类型的唯一用途是将各种 domain 特定的地址结构转换成单个类型以供 socket 系统调用中的各个参数使用。sockaddr 结构通常被定义成如下所示的结构。
        struct sockaddr
        {
	        sa_family_t	sa_family;
	        char	sa_data[14];
        };
        这个结构是所有 domain 特定的地址结构的模板，其中每个地址结构均以与 sockaddr 结构中 sa_family 字段对应的 family 字段打头。
        通过family 字段的值足以确定存储在这个结构的剩余部分中的地址的大小和格式了。

    新的通用套接字地址结构: sockaddr_storage
    在 IPv6 socket API 中新引入了一个通用的 sockaddr_storage 结构，这个结构的空间足以存储任意类型的 socket 地址（即可以将任意类型的 socket 地址结构强制转换并存储在这个结构中）。
    特别地，这个结构允许透明地存储 IPv4 或 IPv6 socket 地址，从而删除了代码中的 IP 版本依赖性。sockaddr_storage 结构在 Linux 上的定义如下所示。
    #define __ss_aligntype uint32_t
    struct sockaddr_storage
    {
    	sa_family_t	ss_family;
    	__ss_aligntype	__ss_align;
    	char	__ss_padding[SS_PADSIZE];
    };

    内核和进程之间的相互复制
        从进程到内核传递套接字地址结构的函数有3个:bind,connect, sendto,这些函数的参数是指向某个套接字地址结构的指针,另一个参数是该结构的整数大小,
        既然指针和指针所指的内容的大小都传递给了内核,于是内核知道需要从进程复制多少数据
        从内核到进程传递套接字地址结构的函数有4个:accept,recvfrom,getsockname,getpeername,这四个函数的其中两个参数是指向某套接字地址结构的指针,和指向该套接字地址结构大小的指针
    当函数被调用时,结构大小是一个值(此值告诉内核该结构的大小,使内核在写此结构时不至于越界),当函数返回时,结构大小又是一个结果(它告诉进程内核在此结构中确切存储了多少信息),这种参数类型叫值-结果参数

字节排序函数

    大端：高字节放低地址，如0x0102,内存中放的是0x0102
    小端：高字节放高地址，低字节放低地址，如0x0102,内存中放的是0x0201
    网际协议使用大端字节序传送多字节整数

    #include <netinet/in h>
    uint16_t htons (uint16t host16bitvalue): //h:host  主机字节序
    uint32_t htonl (uint32t host32bitvalue); //n:network 网络字节序
    uint16_t ntohs (uint16t net16bitvalue);  //s:short
    uint32_t ntohl (uint32t net32bitvalue);  //l:long

字节操纵函数

        str开头：处理C字符串(即以\0结尾)
        b开头：起源与4.2BSD,这里给出源自Berkeley的函数：

    b系列
        bzero
            void bzero(void *dest, size_t nbytes);
            把目标字节串中指定数目的字节置为0.
        bcopy
            void bcopy(const void *src, void *dest, size_t nbytes);
            将指定数目的字节从源字节串移到目标字节串
        bcmp
            int bcmp(const void *ptrl, const void *ptr2, size_t nbytes);
            比较两个任意的字节串，若相同返回0，不同返回非0

        #include<string.h>
        void bzero(void *dest, size_t nbytes);
        void bcopy(const void *src, void *dest, size_t nbytes);
        int bcmp(const void *ptrl, const void *ptr2, size_t nbytes);

    m系列
        memset
            void *memset(void *dest, int c, size_t len);
            把目标字符串指定数目的字节置为c
        memcpy
            void *memcpy(void *dest, const void *src, size_t nbytes);
            类似bcopy，不过两个指针参数的顺序相反。当源字节串与目标字节串重叠时，bcopy能够正确处理，但是memcpy的操作结果却不可知。这种情形下必须该用ANSI C的memmove函数。
        memcmp
            int memcmp(const void *ptr1, const void *ptr2, size_t nbytes);
            比较两个任意的字节串，若相同返回0，否则返回一个非0值

        #include <string.h>
        void *memset(void *dest, int c, size_t len);
        void *memcpy(void *dest, const void *src, size_t nbytes);
        int memcmp(const void *ptr1, const void *ptr2, size_t nbytes);

inet_pton和inet_ntop函数

        这个两个函数的作用是实现ip地址点分十进制格式和二进制格式的相互转换。
        p指表达式, n指数值,地址的表达格式通常是ASCII字符串,而在套接字地址结构中这是二进制值

    inet_pton: 尝试转换由strptr指针所指的字符串，并通过addrptr指针存放二进制结果
        int inet_pton(int family, const char *strptr, void *addrptr);
            family:AF_INET或AF_INET6
            返回：1（成功） 0（不是有效格式） -1（出错）
    inet_ntop: inet_ntop进行相反的转换，从数值格式（addrptr）转换到表达格式（strptr）。len参数是目标存储单元的大小，以免该函数溢出其调用者的缓冲区。
        const char *inet_ntop(int family, const void *addrptr, char *strptr, size_t len);
            family:AF_INET或AF_INET6
            指定size_t防止溢出
                #define INET_ADDRSTRLEN 16
                #define INET6_ADDRSTRLEN 46
            返回：结果指针（成功） NULL（失败）

        #include <arpa/inet.h>
        int inet_pton(int family, const char *strptr, void *addrptr);
        //返回：1（成功） 0（不是有效格式） -1（出错）
        const char *inet_ntop(int family, const void *addrptr, char *strptr, size_t len);
        //返回：结果指针（成功） NULL（失败）

scok_ntop和相关函数

        inet_ntop需要知道地址族, 地址结构中的二进制地址指针

    // IPv4
    struct sockaddr_in addr;
    inet_ntop(AF_INET, &addr.sin_addr, str, sizeof(str));
    // IPv6
    struct sockaddr_in6 addr6;
    inet_ntop(AF_INET6, &addr6.sin_addr, str, sizeof(str));

        以上过程还是比较繁琐的,为了简便起见,我们定义一个sock_ntop函数, 它的参数为
            套接字地址结构指针
            套接字地址结构的长度
            char *sock_ntop(const struct sockaddr *sockaddr, socklen_t addrlen)

/* include sock_ntop */
char *sock_ntop(const struct sockaddr *sa, socklen_t salen)
{
    char        portstr[8];
    static char str[128];       /* Unix domain is largest */

    switch (sa->sa_family) {
        case AF_INET: {
            struct sockaddr_in  *sin = (struct sockaddr_in *) sa;
            if (inet_ntop(AF_INET, &sin->sin_addr, str, sizeof(str)) == NULL)
                return(NULL);
            if (ntohs(sin->sin_port) != 0) {
                snprintf(portstr, sizeof(portstr), ":%d", ntohs(sin->sin_port));
                strcat(str, portstr);
            }
            return(str);
        }
        break;
        ...
    }
    ...
}

readn, writen函数

        字节流套接字(如TCP套接字)上的read和write函数所表现的行为不同于通常的文件I/O.字节流套接字上调用的read和write输入和输出的字节数可能比请求的数量少,这并不是出错. 原因是 内核中用于套接字的缓冲区可能已经达到极限了.
        为了以防万一, 不让实现返回不足的字节,使用writen和readn来改进函数

/* rdwrn.h

   Header file for rdwrn.c.
*/
#ifndef RDWRN_H
#define RDWRN_H

#include <sys/types.h>

ssize_t readn(int fd, void *buf, size_t len);

ssize_t writen(int fd, const void *buf, size_t len);

#endif

/* rdwrn.c

   Implementations of readn() and writen().
*/
#include <unistd.h>
#include <errno.h>
#include "rdwrn.h"                      /* Declares readn() and writen() */

/* Read 'n' bytes from 'fd' into 'buf', restarting after partial
   reads or interruptions by a signal handlers */

ssize_t
readn(int fd, void *buffer, size_t n)
{
    ssize_t numRead;                    /* # of bytes fetched by last read() */
    size_t totRead;                     /* Total # of bytes read so far */
    char *buf;

    buf = buffer;                       /* No pointer arithmetic on "void *" */
    for (totRead = 0; totRead < n; ) {
        numRead = read(fd, buf, n - totRead);

        if (numRead == 0)               /* EOF */
            return totRead;             /* May be 0 if this is first read() */
        if (numRead == -1) {
            if (errno == EINTR)
                continue;               /* Interrupted --> restart read() */
            else
                return -1;              /* Some other error */
        }
        totRead += numRead;
        buf += numRead;
    }
    return totRead;                     /* Must be 'n' bytes if we get here */
}

/* Write 'n' bytes to 'fd' from 'buf', restarting after partial
   write or interruptions by a signal handlers */

ssize_t
writen(int fd, const void *buffer, size_t n)
{
    ssize_t numWritten;                 /* # of bytes written by last write() */
    size_t totWritten;                  /* Total # of bytes written so far */
    const char *buf;

    buf = buffer;                       /* No pointer arithmetic on "void *" */
    for (totWritten = 0; totWritten < n; ) {
        numWritten = write(fd, buf, n - totWritten);

        /* The "write() returns 0" case should never happen, but the
           following ensures that we don't loop forever if it does */

        if (numWritten <= 0) {
            if (numWritten == -1 && errno == EINTR)
                continue;               /* Interrupted --> restart write() */
            else
                return -1;              /* Some other error */
        }
        totWritten += numWritten;
        buf += numWritten;
    }
    return totWritten;                  /* Must be 'n' bytes if we get here */
}

基本TCP套接字编程

socket

    函数:int socket(int family, int type, int protocal);
        framily参数表明协议族(协议域),
        type参数表示套接字类型
        protocal表示协议类型(或则设置为0)
    并不是所有的family和type的组合都是有效的
    AF_前缀表示地址族,PF_前缀表示协议族
    socket函数的返回值为一个非负整数(套接字描述符, sockfd)

connect

    函数:int connect(int sockfd, const struct sockaddr* servaddr, socklen_t addrlen);
        sockfd:套接字描述符
        第二三个参数表示一个套接字地址结构(内部有服务器IP+Port)

    #include <sys/socket.h>
    int connect(int sockfd, const sockaddr * servaddr, socklen_t addrlen);
    //成功返回0，出错为-1

bind

    常见错误“address already in use”

#include <sys/socket.h>
int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen);
//成功返回0，出错返回-1

listen

    监听套接字维护两个队列：
        未完成连接队列（SYN_RCVD)和已完成连接队列(ESTABLISHED)。
        backlog要求这两个队列之和不超过它。

#include <sys/socket.h>
int listen(int sockfd, int backlog);
成功返回0，出错返回-1

accept

    accept拥有两个值-结果参数，cliaddr和addrlen可以返回peer端信息，如果不关心，可以置NULL。

    #include <sys/socket.h>
    int accept(int sockfd, struct sockaddr * cliaddr, socklen_t *addrlen);
    //成功返回非负描述符号，出错返回-1

close()

    int close(sockfd);：可以用来关闭套接字，并终止TCP连接
    确实想终止连接可以用 shutdown()函数

服务器: 显示客户端IP和端口号

/* 服务器端显示客户端的ip地址和端口号 */
#include <time.h>
#include "unp.h"
 
#define MAXLINE 4096
#define LISTENQ 1024
//#define SA struct sockaddr
typedef struct sockaddr SA;
typedef int socket_t;
 
int main(int argc, char **argv)
{
	int			listenfd, connfd;
	struct sockaddr_in	servaddr, cliaddr;
	socket_t			len;
	char			buff[MAXLINE];
	time_t			ticks;
 
	listenfd = socket(AF_INET, SOCK_STREAM, 0);
 
	bzero(&servaddr, sizeof(servaddr));
	servaddr.sin_family      = AF_INET;
	servaddr.sin_addr.s_addr = htonl(INADDR_ANY); // 主机字节序转网络字节序
	servaddr.sin_port        = htons(1300);	/* daytime server */
 
	bind(listenfd, (SA *) &servaddr, sizeof(servaddr)); // 强转为通用套接字地址结构
 
	listen(listenfd, LISTENQ); // 转化为监听套接字
 
	for ( ; ; ) {
		len = sizeof (cliaddr); // 2017.08.06
		connfd = accept(listenfd, (SA *)&cliaddr, &len); // 2017.08.06
		printf("connection from %s, port %d\n",
				inet_ntop(AF_INET, &cliaddr.sin_addr, buff, sizeof(buff)),
				ntohs(cliaddr.sin_port)); // 2017.08.06
 
        		ticks = time(NULL);
       	 	snprintf(buff, sizeof(buff), "%.24s\r\n", ctime(&ticks));
        		write(connfd, buff, strlen(buff));
 
		close(connfd);
	}
}

并发服务器

/* 伪代码 */
pid_t pid;
int   listenfd, connfd;
listenfd = socket (...);
bind (listenfd, ...);
listen (listenfd, LISTENQ);
for (; ; ) {
    connfd = accept (listenfd, ...);
    if ((pid = fork()) == 0) {
        close (listenfd); /* child closes listening socket */
        /* do something */
        close (connfd);   /* done with this client */
        exit (0);
    }
    close (connfd);       /* parent closes connected socket */
}

本地和外地协议地址函数

#include <sys/socket.h>
int getsockname (int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);
int getpeername (int sockfd, struct sockaddr *peeraddr, socklen_t *addrlen);

    在一个没有调用bind的TCP客户端上，connect成功返回后，getsockname用于返回由内核赋予该连接的本地IP地址和本地端口号；
    在以端口号0调用bind后，getsockname用于返回由内核赋予的本地端口号；
    getsockname可用于获取某个套接字的地址族。
    当一个服务器是由调用过accept的某个进程通过调用exec执行程序时，它能够获取客户身份的唯一途径便是调用getpeername。

/* 代码演示：获取套接字的地址族 */
int sockfd_to_family(int sockfd)
{
	struct sockaddr_storage ss;
	socklen_t	len;
 
	len = sizeof(ss);
	if (getsockname(sockfd, (SA *) &ss, &len) < 0)
		return(-1);
	return(ss.ss_family);
}

    大多数TCP服务器是并发的，大多数UDP服务器是迭代的。

TCP客户端和服务器程序示例

    本章开始编写一个完整的TCP客户/服务器程序实例。
    (1) 客户冲标准输入读入一行文本，并写给服务器
    (2）服务器从网络输入读入这行文本，并回射给客户
    (3）客户从网络读入这行回射文本，并显示在标准输出上。
    完整的TCP客户/服务器程序实例

Client

#include "unp.h"
int main(int argc, char **argv)
{
	int sockfd;
	struct sockaddr_in servaddr;
	
	if (argc != 2)
	    err_quit("usage: tcpcli <IPaddress>");
	
	sockfd = Socket(AF_INET, SOCK_STREAM, 0);
	
	bzero(&servaddr, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_port = htons(SERV_PORT);
	inet_pton(AF_INET, argv[1], &servaddr.sin_addr);
	
	connect(sockfd, (SA *) &servaddr, sizeof(servaddr));
	
	str_cli(stdin, sockfd);/* do it all */
	exit(0);
}
void str_cli(FILE *fp, int sockfd)
{
	char sendline[MAXLINE], recvline[MAXLINE];
	while (fgets(sendline, MAXLINE, fp) != NULL) {
		writen(sockfd, sendline, strlen(sendline) );
		if (readline(sockfd, recvline, MAXLINE) == 0)
		    err_quit("str_cli: server terminated prematurely");
		fputs(recvline, stdout);
	}
}

Server

#include "unp.h"
int main(int argc, char **argv) {
	int listenfd, connfd;
	pid_t childpid;
	socklen_t clilen;
	struct sockaddr_in cliaddr, servaddr;
	
	listenfd = Socket(AF_INET, SOCK_STREAM, 0);
	
	bzero(&servaddr, sizeof(servaddr));
	servaddr.sin_family      = AF_INET;
	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
	servaddr.sin_port        = htons(SERV_PORT);
	
	bind(listenfd, (SA *) &servaddr, sizeof(servaddr));
	listen(listenfd, LISTENQ);
	
	for ( ; ; ) {
		clilen = sizeof(cliaddr);
		connfd = accept(listenfd, (SA *) &cliaddr, &clilen);
		if ( (childpid = fork()) == 0) {/* child process */
			close(listenfd);/* close listening socket */
			str_echo(connfd);/* process the request */
			exit(0);
		}
		close(connfd);/* parent closes connected socket */
	}
}

void str_echo(int sockfd) {
	ssize_t n;
	char buf[MAXLINE];
	
	again:
	while ( (n = read(sockfd, buf, MAXLINE)) > 0)
	    writen(sockfd, buf, n);
	
	if (n < 0 && errno == EINTR)
	    goto again;
	else if (n < 0)
	    err_sys("str_echo: read error");
}

工作流程

    服务端先在后台运行。
        连接阶段:
            socket 创建套接字，
            调用bind 设置服务的端口号为9877， 任意一个网卡的IP，
            调用listen,将套接字改为被动连接套接字，
            维护队列，这一步完成后就可以接收客户的connect了，
            调用accept，初次调用时并没有已连接的套接字，进入睡眠。
        工作阶段:
        创建子进程:
            将accept放在一个无限循环中，
            accept返回成功，就fork一个子进程，
            在子进程中处理已建立连接的任务，父进程就继续等待下一个连接。
        子进程工作:
            在子进程中需要关闭socket创建的描述符，父进程中关闭connect返回的描述符，
                因为fork创建进程时这两个描述符都会复制到子进程中，如果不关闭，在子进程退出时由于父进程还打开了connect描述符，将不会发送FIN字节，而且每一个连接都会消耗一个描述符资源永远不会释放。
        在str_echo中，服务器从套接字中读取内容，若没有内容就阻塞，然后直接写回套接字。

    客户端
        链接阶段:
            创建套接字，
            设置服务器IP和端口好，
            调用connect发起连接，
                调用connect后会发送SYN字节，
                在收到服务端的ACK后，
                connect就返回，进入established状态。
        工作阶段
            从标准输入中读取一行文本
            将它写到套接字中
            从套接字中读一行文本
            写到标准输出

客户和服务器正常启动

    客户端正常是阻塞在fgets，等待用户输入。
    在用户输入EOF后，fgets返回NULL，str_cli退出
    客户端程序调用exit结束程序，
        exit首先会先关闭打开的套接字描述符，(客户端套接字close)
        引发FIN发送到套接字中，进入FIN_WAIT_1状态，(客户端发送FIN)
        收到服务器的ACK后进入FIN_WAIT_2状态，(服务器发送回复:ACK)
        再收到FIN后发送ACK然后进入TIME_WAIT状态(服务器发送:FIN, 客户端回复:ACK)
        等待2MSL。

    避免产生僵尸进程

    让父进程调用wait或waitpid.
        子进程在结束后内核会向父进程发送一个SIGCHLD信号，通知父进程子进程已经结束。
        这时父进程如果设置了信号处理函数那么就可以在信号处理函数中调用wait或waitpid.
        如果创建的子进程不止一个，
            那么需要在一个循环中调用waitpid来处理，并且设置WNOHANG参数，
            因为一个wait/waitpid只处理一个僵尸进程，而且调用wait时会挂起，这在信号处理函数中是不妥的。
            如果父进程不设置信号处理函数，那么就可以在父进程退出时调用wait,或waitpid，通常这种情况下父进程都是很快就退出，不然还是会产生僵尸进程。
    让init进程处理僵尸进程。
        这种情况下存在于:
            父进程没有处理SIGCHLD信号，或在信号处理函数中没有waitpid，
            且父进程已经结束后才存在的情况。
        这时init就会成为僵尸进程的父进程，我们就不用管了。
            其实这中情况多半是由于父进程忘记处理了。
        这里我们可以不处理SIGCHLD信号，因为这个信号并不会导致程序结束，只要在父进程中close后面调用wait / waitpid，就可以了。

考虑慢系统调用被中断的情况

    为了说明这个问题，我们引入信号处理函数，其实信号处理就相当于一个软件中断，中断随时都可能发生，因此我们编写代码过程中需要考虑中断的情况。

void sig_chld(int signo);

int main(int argc, char **argv){
	int listenfd, connfd;
	pid_t childpid;
	socklen_t clilen;
	struct sockaddr_in cliaddr, servaddr;
		
	listenfd = socket(AF_INET, SOCK_STREAM, 0);
	bzero(&servaddr, sizeof(servaddr));
	servaddr.sin_family      = AF_INET;
	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
	servaddr.sin_port        = htons(SERV_PORT);

	bind(listenfd, (SA *) &servaddr, sizeof(servaddr));
	listen(listenfd, LISTENQ);
	Signal(SIGCHLD, sig_chld);

	for ( ; ; ) {
		clilen = sizeof(cliaddr);
		connfd = accept(listenfd, (SA *) &cliaddr, &clilen);
		
		if ( (childpid = fork()) == 0) {/* child process */
			close(listenfd);/* close listening socket */
			str_echo(connfd);/* process the request */
			exit(0);
		}
		close(connfd);/* parent closes connected socket */
	}
}

void sig_chld(int signo){
	pid_t pid;
	int stat;
	printf("enter sig_chld\n");
	while ( (pid = waitpid(-1, &stat, WNOHANG)) > 0)
	    printf("child %d terminated\n", pid);
	printf("quit sig_chld\n");
	return;
}

    上面例子中中断处理函数中调用printf是不太合适的，因为printf是不可重入函数，在程序规模比较大，进程多时可能出现奇怪错误，这里只为了查看程序状态。

    Signal是一个书中作者写的一个包裹函数，采用signation函数实现，实现代码中可以选择设置SA_RESTART, 这个配置就表示当系统调用被中断以后是否自动重新启动。

    因为不同的UNIX系统实现可能不一样，有些系统默认重启有些则默认不重启，因此我们自己配置就可以更好控制，当然也为了不用直接配置signation，才将其包装起来。

    对于accept、read、write、select等慢系统调用通常我们都希望他们被中断之后能继续返回中断前的状态继续执行，因为并不会产生错误，
    而对于connect在中断之后我们则不能重启，因为在中断之后其连接肯定会失败。

    当服务器在accept阻塞时，假如进程突然崩溃，
        此时子进程退出时:
            发FIN字节发送到套接字，客户端收到后回应以一个ACK
            同时内核向父进程发送一个SIGCHLD信号，父进程调用sig_chil处理，处理完成后返回accept调用
        那么这时问题就来了，如果没有配置自动重启标识，
            accept调用将出错，并将errno 设为EINTR，
            正确的处理应该是退出程序，但是显然我们不希望这个结果。

    解决方案:
        在配置信号处理函数时，设置act.sa_flags |= SA_RESTART;这样当accept被中断返回后，能继续 阻塞。
        修改accept的判断条件: 当accept返回错误时，我们可以判断一下是否errno为EINTR，如果是我们就手动重启accept。
            Code: 注意这里我们调用的时accept 而不是 包裹函数Accept.

        connfd = accept(listenfd, (SA *) &cliaddr, &clilen);
        if(connfd < 0){
        	if (errno == EINTR){
        		continue;
        	} else {
        		err_sys("accept error");
        	}
        }

服务器进程意外终止

    这个问题也可以用上面的情形测试，我们通过kill掉服务器子进程来模拟。
    对于客户端
        当服务器终止后会发送的FIN字节(表明服务端不在发送内容)，客户端自动以ACK回应
        然后服务器被强行毙掉
        但客户端并不知道服务器进程已经被毙掉了(它只收到了FIN,并不能说明它被毙掉了)，因为客户端此时是阻塞于fgets的，并不会发送FIN字节给服务器，此时客户端认为链接并没有关闭，因此一直等待用户从标准输入输入字符
        如果用户一直不输入那么程序永远不知道服务器已经挂了。
        当用户输入一些字符的时候，服务器就会回应一个RST，客户才知道服务器已经挂了，
        如果客户继续发送内容将引发SIGPIPE信号（这种情况很可能发生，因为客户发给服务端的内容可能是分几次发送的，第一次发的时候就会收到RST，在收到RST期间还可能发送很多内容）。
    如何解决：
        这个问题的根本原因在于客户端，它不能仅仅阻塞于fgets,它应该同时关注stdin 和 socket ,任意一个退出都应该及时知道。因此可以使用select来管理这2个描述符。

发送数据格式有限制

当发送字符串时一般没什么问题，只要不同主机都支持同一中字符编码，但是如果发送的是二进制就有很多问题，比如不同主机字节序可能不同、CPU位数不同，各种数据类型占用空间以及对齐格式可能不同，这其实也是二进制文件的兼容性问题，因此兼容难度非常大。
服务器崩溃 或者网络中断

TCP有重传机制，当网络不通时，客户端将不停地重传未收到确认的分组，直到放弃。。。这里可能需要很久的时间，我们当然希望能尽快知道服务器崩溃的消息了，利用SO_KEEPALIVE套接字选项就可以解决这个问题。
I/O复用：select和poll

    UNIX下可用的5种I/O模型：
        阻塞式I/O；
        非阻塞式I/O；
        I/O复用；
        信号驱动式I/O；
        异步I/O。
        UNIX下可用的5种I/O模型

    I/O复用采用轮询的方式处理多个描述符，当有文件准备好时，就通知进程。

        关注点
            I/O复用的应用场合
            采用I/O复用的客户端和服务器程序

    I/O复用的应用场合
        当客户处理多个描述符时（通常是交互式输入和网络套接字），必须使用I/O复用，才能及时告知用户程序套接字的情况
        如果一个TCP服务器既要处理监听又要处理连接套接字，一般要用I/O复用
        如果既要处理TCP，又要处理UDP，一般要用I/O复用
        如果一个服务器要处理多个服务或多个协议如inet守护进程，一般要用I/O复用

select

    int select(int maxfdp1,fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout);
        timeout:告知内核等待指定描述符中的任何一个就绪需要花多少时间

        struct timeval {
        	long tv_sec; /* seconds */
        	long tv_usec; /* microseconds ,许多UNIX向上舍10ms整数倍，再加调度延迟，时间更不准确*/
        }

            表示永远等待下去：置空指针，仅在有描述符准备好I/O时才返回
            等待一段固定的时间：由timeout指定
            根本不等待：定时器值置为0，这称为轮询（poll）
        fd_set变量使用例子(maxfdp1设置为6)：注意3个fd_set指针参数是值-结果参数（返回以后需要重新对感兴趣的位置1）

        fd_set rset;
        FD_ZERO(&rset);
        FD_SET(1, &rset);
        FD_SET(4, &rset);
        FD_SET(5, &rset);

        计时器到时返回0，-1表示出错
    描述符就绪的条件
        一个套接字准备好读的情况：
            接收缓冲区中字节数 >= 接收缓冲区低水位标记的当前大小（默认1，由SO_RCVLOWAT设置）
            读半部关闭(接收了FIN)将不阻塞并返回0
            监听套接字的已连接数不为0，这时accept通常不阻塞
            其上有一个套接字错误待处理，返回-1，error设置成具体的错误条件，可通过SO_ERROR套接字选项调用getsockopt获取并清除
        一个套接字准备好写
            以连接套接字或UDP套接字发送缓冲区中的可用字节数 >= 发送缓冲区低水位标记的当前大小(默认2048，可用SO_SNDLOWAT)
            写半部关闭的套接字，写操作将产生一个SIGPIPE信号
            非阻塞式connect的套接字已建立连接，或者connect以失败告终
            其上有一个套接字错误待处理，返回-1，error设置成具体的错误条件，可通过SO_ERROR套接字选项调用getsockopt获取并清除

    混合使用stdio和select被认为是非常容易犯错误的
        readline缓冲区中可能有不完整的输入行
        也可能有一个或多个完整的输入行

shutdown

    int shutdown(int sockfd, int howto)
        close()把描述符的引用计数减1，shutdown直接激发TCP的正常连接序列的终止
        shutdown告诉对方我已近完成了数据的发送(对方仍然可以发给我)
            SHUT_RD：关闭连接的读这一半
                可以把第二个参数置为SHUT_RD防止回环复制
                关闭SO_USELOOPBACK套接字选项也能防止回环
            SHUT_WR：关闭连接的写这一半，也叫半关闭
            SHUT_RDWR：连接的读半部和写半部都关闭

TCP回射服务器程序

    使用selecet的客户端程序
        版本一:中调用了fgets，fputs，readline等有自己缓冲区的函数，select看不到，这将导致缓冲区中的数据来不及消费。

        void str_cli(FILE * fp, int sockfd){
          char sendline[MAXLINE], recvline[MAXLINE];
          int maxfdp1;
          fd_set rset;
          FD_ZERO(&rset);
          for( ; ; ){
            FD_SET(fileno(fp), &rset); // fileno 将指向file句柄的套接字的指针,转为套接字
            FD_SET(sockfd, &rset);
            maxfdp1 = max(fileno(fp), sockfd) + 1; // maxfdp 必须为最大值+1
            select(maxfdp1, &rset, NULL, NULL, NULL); // 检测可读
            if(FD_ISSET(sockfd, &rset)){
              if(readline(sockfd, recvline, MAXLINE) == 0)
                err_quit("str_cli: server terminated prematurely");
              fputs(recvline, stdout);
            }
            if(FD_ISSET(fileno(fp), &rset)){
              if(fgets(sendline, MAXLINE, fp) == NULL)
                return ;
              writen(sockfd, sendline, strlen(sendline));
            }
          }
        }

        版本二:改用了Read，Write，解决这一问题；并且改用了shutdown来关闭连接而不是用close。修复了批量输入的问题。

        void str_cli(FILE * fp, int sockfd){
          int maxfdp1, stdineof, n;
          fd_set rset;
          char buf[MAXLINE];

          stdineof = 0;
          FD_ZERO(&rset);
          for( ; ; ){
            if(stdineof == 0){ // 是一个初始化为0, 的新标志,当标志位0时,打开标准输入检测
              FD_SET(fileno(fp), &rset);
            }
            FD_SET(sockfd, &rset);
            maxfdp1 = max(fileno(fp), sockfd) + 1;
            Select(maxfdp1, &rset, NULL, NULL, NULL);
            if(FD_ISSET(sockfd, &rset)){
              if((n = Read(sockfd, buf, MAXLINE)) == 0){
                if(stdineof == 1)
                  return ;
                else
                  err_quit("str_cli: server terminated prematurely");
              }
              Write(fileno(stdout), buf, n);
            }
            if(FD_ISSET(fileno(fp), &rset)){
              if((n = Read(fileno(fp), buf, MAXLINE)) == 0){ // 表示读入EOF标志符,文件已经空了
                stdineof = 1;// 关闭标准输入 
                Shutdown(sockfd, SHUT_WR);// 关闭socked 的读操作
                FD_CLR(fileno(fp), &rset); // 从检测位中删除 输入输入检测
                continue;
              }
              Writen(sockfd, buf, n);
            }
          }
        }

    使用select的服务端程序

    #include "unp.h"
    int main(int argc, char const *argv[]) {
      int i, maxi, maxfd, listenfd, connfd, sockfd;
      int nready, client[FD_SETSIZE];
      ssize_t n;
      fd_set rset, allset;
      char buf[MAXLINE];
      socklen_t clilen;
      struct sockaddr_in cliaddr, servaddr;
      listenfd = Socket(AF_INET, SOCK_STREAM, 0);
      bzero(&servaddr, sizeof(servaddr));
      servaddr.sin_family = AF_INET;
      servaddr.sin_port = htons(SERV_PORT);
      servaddr.sin_addr.s_addr = htonl(INADDR_ANY);

      Bind(listenfd, (SA *)&servaddr, sizeof(servaddr));
      Listen(listenfd, LISTENQ);
      maxfd = listenfd;
      maxi = -1;
      for (i = 0; i < FD_SETSIZE; i++){
        client[i] = -1;
      }
      FD_ZERO (&allset);
      FD_SET(listenfd, &allset);
      for( ; ; ){
        rset = allset;
        nready = Select(maxfd + 1, &rset, NULL, NULL, NULL);
        if(FD_ISSET(listenfd, &rset)){
          clilen = sizeof(cliaddr);
          connfd = Accept(listenfd, (SA *)&cliaddr, &clilen);
          for(i = 0; i < FD_SETSIZE; i++)
            if(client[i] < 0){
              client[i] = connfd;
              break;
            }
          if(i == FD_SETSIZE)
            err_quit("too many clients");
          FD_SET(connfd, &allset);
          if(connfd > maxfd)
            maxfd = connfd;
          if(i > maxi)
            maxi = i;
          if(--nready <= 0)
            continue;
        }
        for(i = 0; i <= maxi; i++){
          if((sockfd = client[i]) < 0)
            continue;
          if(FD_ISSET(sockfd, &rset)){
            if((n = Read(sockfd, buf, MAXLINE)) == 0){
                Close(sockfd);
                FD_CLR(sockfd, &allset);
                client[i] = -1;
            }
            else
              Writen(sockfd, buf, n);
            if(--nready <= 0)
              break;
          }
        }
      }
    }

    poll
        int poll(struct pollfd *fdarray, unsigned long nfds, int timeout);
        第一个参数是指向一个结构数组第一个元素的指针。
            每个数组元素都是一个pollfd结构，用于指定测试某个给定描述符fd的条件。

        struct pollfd{
            int fd;
            short events;
            short revents;
        }

        nfds:结构体数组中元素的个数
        timeout:返回前需要等待多长的时间

回射服务器poll版本：

    回射服务器poll版本：

    #include "unp.h"
    #include <linux/fs.h>

    int main(int argc, char const *argv[]) {
      int i, maxi, listenfd, connfd, sockfd;
      int nready;
      ssize_t n;
      char buf[MAXLINE];
      socklen_t clilen;
      struct pollfd client[INR_OPEN_MAX];
      struct sockaddr_in cliaddr, servaddr;

      listenfd = Socket(AF_INET, SOCK_STREAM, 0);

      bzero(&servaddr, sizeof(servaddr));
      servaddr.sin_family = AF_INET;
      servaddr.sin_port = htons(SERV_PORT);
      servaddr.sin_addr.s_addr = htonl(INADDR_ANY);

      Bind(listenfd, (SA*)&servaddr, sizeof(servaddr));

      Listen(listenfd, LISTENQ);
      client[0].fd = listenfd;
      client[0].events = POLLRDNORM; // 普通可读
      for(i = 1; i < INR_OPEN_MAX; i++)
        client[i].fd = -1;
      maxi = 0;
      for( ; ; ){
        nready = Poll(client, maxi + 1, INFTIM);
        if(client[0].revents & POLLRDNORM){
          clilen = sizeof(cliaddr);
          connfd = Accept(listenfd, (SA*)&cliaddr, &clilen);
          for(i = 1; i < INR_OPEN_MAX; i++){
            if(client[i].fd < 0){
              client[i].fd = connfd;
              break;
            }
          }
          if(i == INR_OPEN_MAX)
            err_quit("too many clients");
          client[i].events = POLLRDNORM;
          if(i > maxi)
            maxi = i;
          if(--nready <= 0)
            continue;
        }
        for(i = 1; i <= maxi; i++){
          if((sockfd = client[i].fd) < 0){
            continue;
          }
          if(client[i].revents & (POLLRDNORM | POLLERR)){
            if((n = read(sockfd, buf, MAXLINE)) < 0){
              if(errno == ECONNRESET){
                Close(sockfd);
                client[i].fd = -1;
              } else
                  err_sys("read error");
            } else if(n == 0){
                Close(sockfd);
                client[i].fd = -1;
            } else
                Writen(sockfd, buf, n);
            if(--nready <= 0)
                break;
          }
        }
      }
      return 0;
    }

    总结poll和select的区别：
        poll不用对最大描述符做+1操作
        poll在应对大数目的文件描述符时更快，因为select要求内核需要检查大量描述符对应的fd_set中的每一个bit位，比较费时。
        select可以监控的文件描述符数目是固定的，相对来说教少（1024或2048）。如果需要监控较大的文件描述符或分布较稀疏的的较少的描述符，效率也会很低。
        而对于poll来说，可以创建特定大小的数组来保存监控的描述符，而不受文件描述符值大小的影响，而且poll可以监控的文件描述符数目远大于select。

套接字选项
getsockopt和setsockopt函数

    仅用于套接字
    定义:

    #include <sys/socket.h>
    int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);
    int setsockopt(int sockfd, int level, int optname, void *optval, socklen_t optlen);
    // 均返回：成功0，出错-1

    参数:
        sockfd:一个打开的套接字描述符
        level:(级别)指定系统中解释选项的代码或为通用套接字代码，或为特定于某个协议的代码(IPV4、IPV6、TCP、SCTP)
        optval:指向某个变量的指针，
            setsockopt通过它获取新值，
            getsockopt把已获取的选项当前值存放到*optval
        optlen：optval的长度
    套接字选项粗分为两大基本类型：
        标志选项：启用或禁止某个特性的二元选项
            getsockopt:optval为0表示禁止，否则表示启用
            setsockopt:optval为0用来禁止
        值选项：取得并返回我们可以设置或检查的特定值选项
            用户进程与系统之间传递所指数据类型的值

套接字状态

    accept一直要到三次握手完成以后才返回给服务器已连接的套接字，想在三次握手完成时确保这些套接字选项中的某一个是给 已连接套接字设置的,必须先设置 监听套接字

通用套接字选项

    SO_BROADCAST:
        本选项开启或禁止进程发送广播(仅数据报套接字支持，且需在支持广播消息的网络上如以太网和令牌环网), 可以防止没有设置成广播时发送广播数据：
        如UDP发送一个的目的地址是一个广播地址，但是该选项没设置，就会返回EACCES错误

    SO_DEBUG
        仅由TCP支持，选项开启时内核将为TCP在该套接字发送和接收所有分组保留详细信息，可用trpt查看

    SO_DONTROUTE
        规定外出分组将绕过底层协议的正常路由机制，用来绕过路由表，以强制将分组从特定的接口发出

    SO_ERROR（可获取不能设置）
        套接字发生错误时，将套接字的so_error变量设置为为Unix Exxx值中的一个，也叫待处理错误(pending error),可以用下面两种方式中的一种立即通知进程
            阻塞在select时，返回设置RW中一个或两个条件
            信号驱动IO模型：
                产生SIGIO信号通知进程或者进程组，
                    进程通过访问SO_ERROR获取so_error的值
                getsockopt()返回的整个数值就是待处理错误，
                处理后由内核复位为0
            当进程调用read且没有数据返回时,如果so_error非0(本来该发生阻塞,但是发现有错误产生,则返回)返回-1,error设置为so_error的值，so_error设置为0。
            调用write时so_error非0，返回-1,error设置为so_error的值，so_error设置为0

    SO_KEEPALIVE
        设置保活选项后，2小时后(期间没有数据)TCP自动发送保活探测分节(keep-alive probe),会导致三种情况
            以期望ACK响应，进程得不到通知
            响应RST,表对端已崩溃并重启，套接字的待处理错误设置为ECONNRESET
            没有任何响应，间隔75s再发8个探测分节，11m15s后放弃且把错误设置为ETIMEOUT.如果收到ICMP错误就返回相应错误。
        这是一个清理通向不可达客户的半开连接的好方法

    SO_LINGER
        本选项指定close()函数对面向连接的协议如何操作，默认立即返回，如果有数据残留将尝试把这些数据发送给对端

        要求传送给内核如下结构：

    struct linger {
         int l_onoff;    /*0=off,l_linger被忽略，>nonzero=on*/
         int l_linger;   /*linger time*/
    }
        linger=0:丢弃缓冲区的任何数据，发送RST给对端，没有四分节终止序列，可避免TCP的TIME_WAIT状态。
            可能引发错误：在2MSL内创建另一个化身，刚终止的连接上的旧的分节不被正确的传递到新的化身上
        linger!=0,套接字关闭时内核拖延一段时间：进程将睡眠到所有数据已发送并被确认或延滞时间到
        套接字是非阻塞型的，延滞时间到之前数据没发送完返回EWOULDBLOCK错误
        close()成功返回只能说明发送的数据和FIN已有对端确认，但不代表进程已经读取，所以改用shutdown好一点,当然也能用应用级ACK

    SO_OOBINLINE
        带外数据将被留存在正常的输入队列中(即在线留存)，此时接收函数的MSG_OOB标志不能用来读取带外数据

    SO_RCVBUF和SO_SNDBUF
        套接字接收缓冲区中可用空间大小限定了TCP通告对端窗口的大小
        注意顺序：窗口规模选项是在建立连接时用SYN分节得到的，所以客户需在connect之前，serv需在listen之前
        根据快恢复算法，缓冲区大小至少应是MSS值的四倍，最好是偶数倍

    SO_RCVLOWAT和SO_SNDLOWAT(低水位标记)
        接收低水位标记：select返回可读时接收缓冲区所需的数据量，TCP/UDP、SCTP默认为1
        发送缓冲区：select()返回可写时发送缓冲区所需的可用空间。tcp默认2048，UDP的发送缓冲区的可用字节数从不改变(不保留副本)

    SO_RCVTIMEO和SO_SNDTIMEO
        设置超时值，默认设置为0，即禁止超时

    SO_REUSEADDR和SO_REUSEPORT(重用地址端口)
        监听服务器终止，子进程继续处理连接，重启监听服务器时会出错，而开启了SO_REUSEADDR就不会。
        SO_REUSEADDR允许同一个端口的多个服务器实例(只要不同的本地IP地址即可)，通配地址捆绑一般放到最后
        SO_REUSEADDR允许同一个端口捆绑同一个进程的不同套接字
        SO_REUSEADDR允许UDP完全重复捆绑(一般来说)，用于多播

    SO_TYPE
        本选项返回套接字类型，返回值是一个诸如SOCK_STREAM或SOCK_DGRAM之类的值，通常由启动时继承了套接字的进程使用

    SO_USELOOPBACK
        仅用于路由域(AF_ROUTE)套接字，默认打开。开启时，相应套接字将接收在其上发送的任何数据报的一个副本。

IPv4套接字选项

    IP_HDRINCL
        如果是给原始IP套接字设置的，必须自己构造首部，下列情况例外：
        见Page168
    IP_OPTIONS
        允许在IPv4首部总设置IP选项
    IP_RECVDSTADDR
        开启导致所收到的UDP数据报的目的地址由recvmsg作为辅助函数返回
    IP_RECVIF
        开启导致所收到的UDP数据报的接收接口索引由recvmsg函数作为辅助函数返回
    IP_TOS
        本套接字选项允许我们为TCP、UDP、SCTP设置IP首部中的服务类型字段
    IP_TTL
        用于设置或获取系统用在从某个给定套接字发送的单播分组上的默认TTL值

fcntl函数

    fcntl()函数(file control)可执行各种描述符控制操作
    -
    int fcntl(int fd, int cmd, .../* int arg */);
    每种描述符都有一组由F_GETFL命令获取或由F_SETFL命令设置的文件标志，影响套接字描述符的有两个：
        O_NONBLOCK(非阻塞式IO)
        O_ASYNC(信号驱动式IO)
    正确设置非阻塞式IO的写法：

    int flag;
    /* Set a socket as nonblocking */
    if((flag=fcntl(fd, F_GETFL, 0)) < 0){    //必须要先获取其他文件标志
        err_sys("F_GETFL, error");
    }
    flag |=O_NONBLOCK;                       //或运算，打开非阻塞标志
    if(fcntl(fd, F_SETFL, flags) <0 ){
        err_sys("F_SETFL error");
    }
    flag &=~O_NONBLOCK;                      //与运算，关闭非阻塞标志
    if(fcntl(fd, F_SETFL, flags) <0 ){
        err_sys("F_SETFL error");
    }

    F_SETOWN的参数是正值则指出接收信号的进程ID，是负数则绝对值指出信号的组ID
    F_GETOWN与上面类似
    使用socket()函数创建的套接字没有属组。如果一个新的套接字是从一个监听套接字创建而来，属组将继承过来。

基本UDP套接字编程
recvfrom()和sendto()

    定义:
        ssize_t recvfrom(int sockfd, void *buff, size_t nbytes, int flag, struct sockaddr *from, socklen_t *addrlen);
        ssize_t sendto(int sockfd, const void *buff, size_t nbytes, int flag, const struct sockaddr *to, socklen_t addrlen);
    参数:
        前三个参数 等同于read和write的三个参数:描述符, 指向读/写入缓冲区的指针和读/写字节数
        buff:接收的内容，可以为0
        falg:将在后面讨论
        from: 指向一个由函数返回时候填写的数据报发送者的协议地址的套截止地址结构,返回字节在addrlen
        to: 参数指向一个套接字地址结构(内含数据包接受者协议地址:IP以及Port), 长度由于addrlen指定
        对于UDP客户端而言,是不需要绑定端口的,在第一次调用sendto的时候,内核会给他指派一个临时宽口,换句话时说,在UDP客户端中,如果没有指定端口,又没有调用sendto是无法接收到消息的

            recvfrom像是accept和read的结合
            但是中间多了一个flags参数，将在14章讨论recv、send、recvmsg函数时做介绍。本章都置为0.

UDP回射服务程序

    UDP服务端是一个典型的迭代器模型，大多数TCP服务器是并发的。对于本套接字，UDP层中隐含有排队发送，每个UDP套接字都有一个接收缓冲区，实行FIFO机制。
    Code

#include "unp.h"
void dg_echo(int , SA *, socklen_t);
int main(int argc, char const *argv[]) {
  int sockfd;
  struct sockaddr_in servaddr, cliaddr;

  sockfd = Socket(AF_INET, SOCK_DGRAM, 0); //首次使用数据报类型
  bzero(&servaddr, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_port = htons(SERV_PORT);
  servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
  Bind(sockfd, (SA*)&servaddr, sizeof(servaddr));

  dg_echo(sockfd, (SA*)&cliaddr, sizeof(cliaddr));
}

void dg_echo(int sockfd, SA * pcliaddr, socklen_t clilen){
  int n;
  socklen_t len;
  char msg[MAXLINE];
  for( ; ; ){
    len = clilen;
    n = Recvfrom(sockfd, msg, MAXLINE, 0, pcliaddr, &len); // 接收到消息
    Sendto(sockfd, msg, n, 0, pcliaddr, len); // 又给他发回去
  }
}

UDP回射客户程序

    Code

#include "unp.h"

void dg_cli(FILE *, int, const SA *, socklen_t);

int main(int argc, char const *argv[]) {
  if(argc != 2) err_quit("usage: ./udpcli01 <IPaddress>");

  int sockfd;
  struct sockaddr_in servaddr;

  bzero(&servaddr, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_port = htons(SERV_PORT);
  Inet_pton(AF_INET, argv[1], &servaddr.sin_addr);
  sockfd = Socket(AF_INET, SOCK_DGRAM, 0); 
  // 对于UDP客户端而言,是不需要保定端口的,在第一次调用sendto的时候,内核会给他指派一个临时宽口

  dg_cli(stdin, sockfd, (SA *)&servaddr, sizeof(servaddr));
}

void dg_cli(FILE * fp,int sockfd, const SA * servaddr, socklen_t servlen){
  char buf[MAXLINE];
  int n;
  for( ; ; ){
    if(Fgets(buf, MAXLINE, fp) == NULL)
      return ;
    else
      Sendto(sockfd, buf, strlen(buf), 0, servaddr, servlen);
    if((n = Recvfrom(sockfd, buf, MAXLINE, 0, NULL, NULL)) == 0){
      err_quit("connection close");
    }
    else if(n < 0)
      err_quit("Recvfrom error");
    buf[n] = 0;
    Fputs(buf, stdout);
  }
}

采用UDP的缺点及改进措施

    数据报丢失：
        数据报丢失导致客户阻塞于recvfrom调用，可以设置超时机制解决，14.2节讨论。
    验证接收响应的确认：
        重新malloc一个sockaddr *变量，在Recvfrom获得其值，比较该变量和原先发送的servaddr，相同就是需要的响应。
    服务器进程未运行
        服务器主机响应“port unreachable”ICMP消息，但是此时的进程不能识别这个异步错误，它永远阻塞于recvfrom调用，
        我们需要用connect获取这个ICMP消息。

UDP程序例子小结
UDP的connect函数

    这里的connect()不同于TCP，只检查当前存在立即可知的错误，记录对端IP地址和端口号，然后返回给进程。连接后主要发生三点变化：
        不指定目的地址，即不用sendto(或第六个参数为空指针),改用write()或send().
        不必使用recvfrom()，而改用read(),recv(),recvmsg(),这说明一个UDP套接字仅与一个IP地址作数据交换（多播、广播地址）
        异步错误将返回给进程
    给一个UDP套接字多次调用connect()，以断开套接字或指定新的IP地址和端口号
    - 最便于移植的方法是清零一个地址结构后把它的地址簇成员设置为AF_UNSPEC
    如果要给同一个目的地址发送多个数据报， 显式 connect() 好一点
    Code
        当连接一个没有运行的udp服务器时,连接不会出错，但是发送数据时会返回一个目的端口不可达的ICMP错误，被内核映射成ECONNREFUSED,UnixWare内核不会返回这种错误(page200)

    void dg_cli(FILE *fp, int sockfd, const SA *pservaddr, socklen_t servlen)
    {
    	int	n;
    	char	sendline[MAXLINE], recvline[MAXLINE + 1];

    	Connect(sockfd, (SA *) pservaddr, servlen);

    	while (Fgets(sendline, MAXLINE, fp) != NULL) {

    		Write(sockfd, sendline, strlen(sendline));

    		n = Read(sockfd, recvline, MAXLINE);

    		recvline[n] = 0;	/* null terminate */
    		Fputs(recvline, stdout);
    	}
    }

UDP的外出接口的确定

    connect()函数的一个副作用是可用来确定特定目的地的外出接口(本地IP通过为目的地址搜索路由表得到)

int main(int argc, char **argv){
	int			sockfd;
	socklen_t		len;
	struct sockaddr_in	cliaddr, servaddr;

	if (argc != 2)
		err_quit("usage: udpcli <IPaddress>");

	sockfd = Socket(AF_INET, SOCK_DGRAM, 0);

	bzero(&servaddr, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_port = htons(SERV_PORT);
	Inet_pton(AF_INET, argv[1], &servaddr.sin_addr);

	Connect(sockfd, (SA *) &servaddr, sizeof(servaddr));

	len = sizeof(cliaddr);
	Getsockname(sockfd, (SA *) &cliaddr, &len);
	printf("local address %s\n", Sock_ntop((SA *) &cliaddr, len));

	exit(0);
}

使用select()的TCP和UDP回射服务器程序

    Code

    #include	"unp.h"
    int main(int argc, char **argv){
    	int			listenfd, connfd, udpfd, nready, maxfdp1;
    	char			mesg[MAXLINE];
    	pid_t			childpid;
    	fd_set			rset;
    	ssize_t			n;
    	socklen_t		len;
    	const int		on = 1;
    	struct sockaddr_in	cliaddr, servaddr;
    	void			sig_chld(int);

    	listenfd = Socket(AF_INET, SOCK_STREAM, 0);

    	bzero(&servaddr, sizeof(servaddr));
    	servaddr.sin_family      = AF_INET;
    	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    	servaddr.sin_port        = htons(SERV_PORT);

    	Setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));  //防止该端口上已有连接存在
    	Bind(listenfd, (SA *) &servaddr, sizeof(servaddr));

    	Listen(listenfd, LISTENQ);

    	udpfd = Socket(AF_INET, SOCK_DGRAM, 0);

    	bzero(&servaddr, sizeof(servaddr));
    	servaddr.sin_family      = AF_INET;
    	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    	servaddr.sin_port        = htons(SERV_PORT);

    	Bind(udpfd, (SA *) &servaddr, sizeof(servaddr));

    	Signal(SIGCHLD, sig_chld);	/* must call waitpid(), 因为TCP连接由子进程处理  */

    	FD_ZERO(&rset);
    	maxfdp1 = max(listenfd, udpfd) + 1;
    	for ( ; ; ) {
    		FD_SET(listenfd, &rset);
    		FD_SET(udpfd, &rset);
    		if ( (nready = select(maxfdp1, &rset, NULL, NULL, NULL)) < 0) {
    			if (errno == EINTR)
    				continue;		/* back to for() */
    			else
    				err_sys("select error");
    		}

    		if (FD_ISSET(listenfd, &rset)) {
    			len = sizeof(cliaddr);
    			connfd = Accept(listenfd, (SA *) &cliaddr, &len);
    	
    			if ( (childpid = Fork()) == 0) {	/* child process */
    				Close(listenfd);	/* close listening socket */
    				str_echo(connfd);	/* process the request */
    				exit(0);
    			}
    			Close(connfd);			/* parent closes connected socket */
    		}

    		if (FD_ISSET(udpfd, &rset)) {
    			len = sizeof(cliaddr);
    			n = Recvfrom(udpfd, mesg, MAXLINE, 0, (SA *) &cliaddr, &len);
    			Sendto(udpfd, mesg, n, 0, (SA *) &cliaddr, len);
    		}
    	}
    }

第11 章 名字与地址的转换

        域名系统(Domain Name System, DNS):主要用于主机名字和IP地址之间的映射

资源记录

    DNS中的条目称为资源记录(resource record)
        A记录: 把一个主机名映射为一个32位IPv4地址
        AAAA记录: 把一个主机名映射为一个128位IPv6地址
        PTR记录: 称为指针记录(pointer record)把IP地址映射为主机名
            对于IPv4,将32位地址的4个字节先反转顺序,每个字节都转为换各自的十进制ASCII值后,在添加in-addr.arpa,结果字符串用于PTR查询
            对于IPv6, 128位地址的32个四位组先反转顺序,每个四位组都转换成相应的十六进制的ASCII值后在添加ip6.arpa
        MX记录: 把一个主机指定作为给定主机的“邮件交换器”
        CNAME: 代表”canonical name”(规范名字),常见的用法是为常用的服务指派CNAME记录

解析器(resolver)和名字服务器(name server)

    应用程序通过调用解析器函数库中的函数(gethostbyname,gethostbyaddr)接触DNS服务器
    解析器函数库中的代码通过读取系统相关配置文件(/etc/resolv.conf)确定本地name server的地址
    解析器使用UDP向本地name server发出查询，如果本地name server不知道答案，解析器就会使用UDP向整个因特网查询其他的名字服务器；如果答案太长超过了UDP的承载能力，自动切换到TCP
    resolver可以看成DNS的客户端；nameserver可以看成DNS的服务器

DNS替代方法

    静态主机文件(/etc/hosts)
    网络信息系统(NIS)
    轻量级目录访问协议(LDAP)

gethostbyname

    在新的程序中应该使用getaddrinfo
    函数定义: struct hostent * gethostbyname(const char * hostname);
        返回: 成功则返回非空指针, 失败则NULL且设置h_errno
            注意此函数失败之后并不会设置errno变量,而是将全局整数变量h_errno设置为在头文件<netdb.h>中定义的常值之一:
                HOST_NOT_FOUND
                TRY_AGAIN
                NO_RECOVERY
                NO_DATA(等同于NO_ADDRESS)
                    此错误表示所指向的名字有效,但是没有A记录
        返回值类型:

    	struct hostent{
    	char	*h_name;
    	char	**h_aliases;
    	int	h_addrtype;
    	int	h_length;
    	char**	h_addr_list;
    	}

    例子

#include "unp.h"
int main(int argc, char const *argv[]) {
  char * ptr, ** pptr;
  char str[INET_ADDRSTRLEN];
  struct hostent * hptr;

  while (--argc > 0) {
    ptr = * ++argv;
    if ((hptr = gethostbyname(ptr)) == NULL) {
      err_msg("gethostbyname error for host :%s : %s", ptr, hstrerror(h_errno));
      continue;
    }
    printf("official hostname: %s\n", hptr->h_name);

    for (pptr = hptr->h_aliases; *pptr != NULL; pptr++)
      printf("\talias: %s\n", *pptr);

    switch (hptr->h_addrtype) {
    case AF_INET:
      pptr = hptr->h_addr_list;
      for (; *pptr != NULL; pptr++)
        printf("\taddress : %s\n",
               Inet_ntop(hptr->h_addrtype, * pptr, str, sizeof(str)));
      break;
    default:
      err_ret("unknown address type");
      break;
    }
  }
  return 0;
}

11.4 gethostbyaddr

    在新的程序中应该使用getnameinfo
    gethostbyaddr函数试图由一个二进制的IP地址找到相应的主机名，与 gethostbyname 的行为刚好相反。
    注：此处与原书中的 gethostbyaddr函数不同，原书中的函数在库<netdb.h>，且addr参数为 const char *

#include <sys/socket.h>
struct hostent * gethostbyaddr(const void * addr,socklen_t len,int type);
//if success return not NULL pointer,if error return NULL and set h_errno

    addr 参数是一个指向IPV4地址的某个in_addr结构的指针；len参数是这个结构的大小；family参数为AF_INET或AF_INET6
    按照DNS的说法， gethostbyaddr 在 in_addr.arpa 域中向一个名字服务器查询 PTR记录。

11.5 getservbyname 和 getservbyport

        服务名到端口号的映射关系保存在文件/etc/services。

    getservbyname 函数用于根据给定的名字查找相应服务
        相关声明

        #include <netdb.h>
        struct servent * getservbyname(const char * servname,const char * protoname);
        //if success return not NULL pointer,if error return NULL
        struct servent
        {
        	char * s_name; //Official services name
        	char ** s_aliases; //Alias list
        	int s_port; //Port number,Network byte order
        	char * s_proto; //Protocol to use
        }

            服务名参数 servname 必须指定。
            如果同时指定了协议(即 protoname 参数为非空指针)，那么指定服务必须有匹配的协议。
                有些因特网服务既用 TCP 也用 UDP 提供，其他因特网则仅仅支持单个协议。
            如果 protoname未指定而 servname 指定服务支持多个协议，那么返回哪个端口号取决于实现。
                通常情况下这种选择无关紧要，因为支持多个协议的服务往往使用相同的 TCP 端口号和 UDP 端口号，不过这点并无保证。
            servent 结构中我们关心的主要字段是端口号(网络字节序)。
                既然端口号是以网络字节序返回的，把它存放到套接字地址结构时绝对不能调用 htons。
            该函数的典型调用：

            struct servent *sptr;
            sptr=getservbyname("domain","udp"); //DNS using UDP
            sptr=getservbyname("ftp","tcp"); //FTP using TCP
            sptr=getservbyname("ftp",NULL); //FTP using TCP
            sptr=getservbyname("ftp","udp"); //this call will fail

    getservbyport 函数用于给定端口号和可选协议查询相应服务
        相关定义

        #include <netdb.h>
        struct servent * getservbyport(int port,const char * protoname);
        //if success return not NULL pointer,if error return NULL

        port参数的值必须为网络字节序。该函数的典型调用如下：

        struct servent *sptr;
        sptr=getservbyport(htons(53),"udp"); //DNS using UDP
        sptr=getservbyport(htons(21),"tcp"); //FTP using TCP
        sptr=getservbyport(htons(21),NULL); // FTP using TCP
        sptr=getservbyport(htons(21),"udp"); //this call will fail

    必须清楚的是，某些端口号在 TCP 上是一种服务，在 UDP 上却用于完全不同的另一种服务。
        端口可以复用,只要协议不同

    例子：

    #include "unp.h"
    int main(int argc, char const *argv[]) {
      int sockfd, n;
      char recvline[MAXLINE + 1];
      struct sockaddr_in servaddr;
      struct in_addr ** pptr;
      struct in_addr * inetaddrp[2];
      struct in_addr inetaddr;
      struct hostent * hp;
      struct servent * sp;

      if (argc != 3)
        err_quit("usage: daytimetcpcli1 <hostname> <services>");

      if ((hp = gethostbyname(argv[1])) == NULL) {
        if (inet_aton(argv[1], &inetaddr) == 0)
          err_quit("hostname error for %s : %s", argv[1], hstrerror(h_errno));
        else {
          inetaddrp[0] = &inetaddr;
          inetaddrp[1] = NULL;
          pptr = inetaddrp;
        }
      } else
        pptr = (struct in_addr ** )hp->h_addr_list;

      if ((sp = getservbyname(argv[2], "tcp")) == NULL)
        err_quit("getservbyname error for %s : %s", argv[2]);

      for (; *pptr != NULL; pptr++) {
        sockfd = Socket(AF_INET, SOCK_STREAM, 0);

        bzero(&servaddr, sizeof(servaddr));
        servaddr.sin_family = AF_INET;
        servaddr.sin_port = sp->s_port;
        memcpy(&servaddr.sin_addr, * pptr, sizeof(struct in_addr));
        printf("trying %s \n", Sock_ntop((SA *)&servaddr, sizeof(servaddr)));

        if (connect(sockfd, (SA *)&servaddr, sizeof(servaddr)) == 0)
          break;
        err_ret("connect error");
        close(sockfd);
      }

      if (*pptr == NULL)
        err_quit("unable to connect");

      while ((n = Read(sockfd, recvline, MAXLINE)) > 0) {
        recvline[n] = 0; // null terminate
        Fputs(recvline, stdout);
      }
      return 0;
    }

11.6 getaddrinfo

    gethostbyaddr 和 gethostbyname 这两个函数仅仅支持IPv4。
    getaddrinfo
        能够处理名字到地址以及服务到端口这两种转换，返回的是一个 addrinfo 结构链表。这些 addrinfo 结构随后可由套接字函数直接使用。
        如此一来， getaddrinfo 函数把协议相关性完全隐藏在这个库函数内部。 应用程序只需要处理由 getaddrinfo 填写的套接字地址结构。
        该函数在POSIX规范中定义。

    #include <netdb.h>
    int getaddrinfo(const char * hostname,const char * service,const struct addrinfo *hints,struct addrinfo **result);
    //if success return 0,if error return not 0;
        1
        2
        3

    参数:
        hostname参数是一个主机名或地址串(IPv4的点分十进制数串或IPv6的十六进制数串)。
        service参数是一个服务名或十进制端口号数串。
        hints参数可以是一个空指针，也可以是一个指向某个addrinfo结构指针，调用者在这个结构中填入期望返回的信息类型的暗示。
        result参数, 如果该函数返回成功(0)，那么由result参数指向的变量已被填入一个指针，它指向的是由其中的ai_next成员串接起来的addrinfo结构链表(多个addrinfo结构返回时，这些结构的先后顺序没有保证 )。
            可导致返回多个addrinfo结构情形有以下两个：
                如果与hostname参数关联的地址有多个，那么适用于所请求地址族(可通过hints结构的 ai_family成员设置)的每个地址都返回一个对应的结构
                如果service参数指定的服务支持多个套接字类型，那么每个套接字类型都可能返回一个对应的结构，具体取决与 hints结构的ai_socktype成员。
            （注意，getaddrinfo 的多数实现认为只能按照由 ai_socktype 成员请求的套接字类型端口号数串到端口的转换，如果没有指定这个成员，那就返回一个错误）
    addrinfo的定义如下

    struct addrinfo{
    	int ai_flags; //AI_PASSIVE,AI_CANONNAME
    	int ai_family; //AF_XXX
    	int ai_socktype; //SOCK_XXX
    	int ai_protocol; //0 or IPPROTO_XXX for IPV4 and IPV6
    	socklen_t ai_addrlen; //length of ai_addr
    	char * ai_canonname; //ptr to canonical name for host
    	struct sockaddr * ai_addr; //ptr to socket address structure
    	struct addrinfo * ai_next; //ptr to next structure in linked list
    }

addrinfo结构中调用者(hints)可以设置的成员有, (如果hints参数是一个空指针，该函数就假设 ai_flags, ai_socktype, ai_protocol 的值均为0，ai_family的值为AF_UNSPEC。)：
调用者(hints)	可以设置的成员包括
ai_flags		零个或多个在一起的AI_XXX值.
ai_family	某个AF_XXX
ai_socktype	某个SOCK_XXX值
ai_protocol	某个写控制协议
ai_flags可能值	含义
AI_PASSIVE		套接字将用于被动打开。
AI_CANONNAME		告知 getaddrinfo 函数返回主机的规范名字。
AI_NUMERICHOST	防止任何类型的名字到地址映射， hostname参数必须为一个地址串
AI_NUMERICSERV	防止任何类型的名字到服务的映射,service 参数必须是一个十进制端口号数串。
AI_V4MAPPED		如果同时指定 ai_family 成员的值为 AF_INET6,那么如果没有可用的AAAA记录，就返回与A记录对应的IPV4映射的IPV6地址。
AI_ALL			如果同时指定 AI_V4MAPPED 标志，那么除了返回与AAAA记录对应的IPV6地址外，还返回与A记录对应的IPV4映射的IPV6地址。
AI_ADDR		CONFIG	按照所在主机的配置选择返回地址类型，也就是只查找与所在主机回馈接口以外的网络接口配置的IP地址版本一致的地址。

    一些常见的输入 (如清楚知道自己需要的套接字类型，应该在hints中设置ai_socktype成员,避免返回多个结构，甚至出现错误的ai_socktype值) ：
        指定hostname和service。这是TCP或UDP客户进程调用getaddrinfo的常规输入。
        对于TCP客户在一个循环中针对每个返回的IP地址，调用socket和connect，直到有一个连接成功，或者所有地址尝试完毕为止。
        对于UDP客户由getaddrinfo填入的套接字地址结构用于 sendto 或 connect。
        只指定service而不指定hostname，同时在hints结构中指定 AI_PASSIVE标志。这是典型的服务器进程.
            返回的套接字地址结构中应含有一个值为 INADDR_ANY(IPV4)或IN6ADDR_ANY_INIT(IPV6)。
            TCP 服务器随后调用 socket、bind、listen、accept。
            UDP服务器将调用 socket、bind、recvfrom。

gai_strerror

    getaddrinfo返回非0值表示错误,而gai_strerror可以通过此非0值返回一个指向对应的出错信息串的指针。

#include <netdb.h>
const char * gai_strerror(int error);
// 返回：指向错误描述消息字符串的指针

    getaddrinfo 返回的非0错误常值：

常数	说明
EAI_AGAIN	名字解析中临时失败
EAI_BADFLAGS	ai_flags的值无效
EAI_FAIL		名字解析中不可恢复地失败
EAI_FAMILY	不支持 ai_family
EAI_MEMORY	内存分配失败
EAI_NONAME	hostname或service未提供，或者不可知
EAI_OVERFLOW	用户参数缓冲区溢出（仅限 getnameinfo 函数）
EAI_SERVICE	不支持 ai_socktype 类型的service
EAI_SOCKTYPE	不支持 ai_socktype
EAI_SYSTEM	在 errno 变量中有系统错误返回
freeaddrinfo

    由getaddrinfo返回的所有存储空间都是动态获取的（如malloc调用），包括addrinfo结构、ai_addr结构和ai_canonname字符串。
    这些存储空间通过freeeaddrinfo返还给系统：

#include <netdb.h>
void freeaddrinfo(struct addrinfo *ai);
// ai 参数应指向由 getaddrinfo 返回的第一个 addrinfo 结构。

getaddrinfo：IPv6

    POSIX 规范定义了 getaddrinfo 函数以及该函数为IPV4或IPV6返回的信息。
    我们注意以下几点：
        getaddrinfo 在处理两个不同的输入：
            一个是套接字地址结构类型，调用者期待返回的地址结构符合这个类型；
            另一个是资源记录类型，在DNS或其他数据库中执行的查找符合这个类型。
        由调用者在hints结构中提供的地址族指定调用者期待返回的套接字地址结构的类型
        POSIX声称如果调用者指定AF_UNSPEC,那么getaddrinfo函数返回的是适合于指定主机名和服务名且适合任意协议族的地址
        POSIX的这个声明也意味着如果设置了AI_PASSIVE标志但是没有指定主机名，那么IPV6通配地址(IN6ADDR_ANY_INIT或0::0)应该作为sockaddr_in6结构返回，
        同样IPV4通配地址 (INADDR_ANY 或 0.0.0.0)应该作为sockaddr_in结构返回.
        在hints结构的ai_family成员中指定的地址族以及在ai_flags成员中指定的AI_V4MAPPED和AI_ALL等标志决定了在DNS中查找的资源记录类型.
        主机名参数还可以是IPV6的十六进制数串或IPV4的点分十进制数串。这个数串的有效性取决于调用者指定的地址族
        POSIX 规范定义了 getaddrinfo 函数以及该函数为IPV4或IPV6返回的信息。在下表汇总这些返回值之前，我们注意以下几点：

    getaddrinfo 在处理两个不同的输入：一个是套接字地址结构类型，调用者期待返回的地址结构符合这个类型；另一个是资源记录类型，在DNS或其他数据库中执行的查找符合这个类型。
    由调用者在hints结构中提供的地址族指定调用者期待返回的套接字地址结构的类型
    POSIX声称如果调用者指定AF_UNSPEC,那么 getaddrinfo 函数返回的是适合于指定主机名和服务名且适合任意协议族的地址
    POSIX的这个声明也意味着如果设置了 AI_PASSIVE 标志但是没有指定主机名，那么 IPV6 通配地址（IN6ADDR_ANY_INIT或0::0）应该作为 sockaddr_in6 结构返回，
    同样 IPV4 通配地址 (INADDR_ANY 或 0.0.0.0)应该作为 sockaddr_in 结构返回
    在 hints 结构的 ai_family 成员中指定的地址族以及在 ai_flags 成员中指定的 AI_V4MAPPED 和 AI_ALL 等标志决定了在 DNS中查找的资源记录类型
    主机名参数还可以是IPV6的十六进制数串或IPV4的点分十进制数串。这个数串的有效性取决于调用者指定的地址族

getaddrinfo:例子

static void do_funccall(const char *host, const char *serv, int flags, int family, int socktype, int protocol, int exprc)
{
	int		rc;
	struct addrinfo	hints, *res;
	memset(&hints, 0, sizeof(struct addrinfo));
	hints.ai_flags = flags;
	hints.ai_family = family;
	hints.ai_socktype = socktype;
	hints.ai_protocol = protocol;
	rc = getaddrinfo(host, serv, &hints, &res);
	if (rc != exprc) {
		printf("expected return = %d (%s),\nactual return = %d (%s)\n",
				exprc, gai_strerror(exprc), rc, gai_strerror(rc));
		if (host != NULL)
			printf("  host = %s\n", host);
		if (serv != NULL)
			printf("  serv = %s\n", serv);
		printf("  flags = %d, family = %s, socktype = %s, protocol = %d\n",
				flags, str_fam(family), str_sock(socktype), protocol);
		exit(2);
	}
}

<unp.h>提供的实用的函数接口
host_serv

    访问getaddrinfo的第一个接口函数不要求调用者调用者分配并填写一个 hints 结构。
    该结构中我们感兴趣的两个字段(地址族和套接字类型)成为这个名为host_serv的接口函数的参数。

#include "unp.h"
struct addrinfo *host_serv(const char *hostname,const char *service,int family,int socktype);
// 返回：若成功则为指向 addrinfo 结构的指针，若出错则为 NULL
struct addrinfo * host_serv(const char *hostname,const char *service,int family,int socktype)
{
	int n;
	struct addrinfo hints, * res;

	bzero(&hints,sizeof(struct addrinfo));
	hints.ai_flags=AI_CANONNAME ; //always return canonical name
	hints.ai_family=family; //AF_UNSPEC,AF_INET,AF_INET6,etc .
	hints.ai_socktype=socktype; //0,SOCK_STREAM,SOCK_DGRAM,etc .

	if ((n=getaddrinfo(host,serv,&hints,&res))!=0) return NULL;
	return res;
}

tcp_connect

    tcp_connect函数执行客户的通常步骤：创建一个TCP套接字并连接到一个服务器：

#include "unp.h"
int tcp_connect(const char * hostname,const char * service);
// 返回：若成功则为已连接的套接字描述符，若出错则不返回
int tcp_connect(const char *host, const char *service) {
  int sockfd, n;
  struct addrinfo hints, *res, *ressave;

  bzero(&hints, sizeof(struct addrinfo));
  hints.ai_family = AF_UNSPEC;
  hints.ai_socktype = SOCK_STREAM;

  if ((n = getaddrinfo(host, service, &hints, &res)) != 0)
    err_quit("tcp_connect error for %s , %s : %s", host, service, gai_strerror(n));
  ressave = res;
  do {
    sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
    if (sockfd < 0) continue; // ignore this one
    if (connect(sockfd, res->ai_addr, res->ai_addrlen) == 0) break; // success
    Close(sockfd); // ignore this one
  } while ((res = res->ai_next) != NULL);

  if (res == NULL) // errno set from final connect()
    err_sys("tcp_connect error for %s ,%s", host, service);
  freeaddrinfo(ressave);
  return sockfd;
}

    例子：时间获取客户程序

#include "unp.h"
int main(int argc, char const *argv[]) {
  int sockfd, n;
  char recvline[MAXLINE + 1];
  socklen_t len;
  struct sockaddr_storage ss;
  if (argc != 3) err_quit("usage : daytimetcpcli <hostname/IPaddress> <service/prot#>");

  sockfd = Tcp_connect(argv[1], argv[2]);
  len = sizeof(ss);
  Getpeername(sockfd, (SA *)&ss, &len); // 获取对端(服务器端)的协议地址
  printf("connected to %s \n", Sock_ntop_host((SA *)&ss, len));
  while ((n = Read(sockfd, recvline, MAXLINE)) > 0) {
    recvline[n] = 0;
    Fputs(recvline, stdout);
  }
  return 0;
}

tcp_listen

    tcp_listen函数执行 TCP 服务器的通常步骤：创建一个TCP套接字，给它捆绑服务器的众所周知的端口，并允许接受外来的连接请求。

#include "unp.h"
int tcp_listen(const char * hostname,const char * service, socklen_t *addrlenp);
// 若成功则为以连接套接字描述符，若出错则不返回

int tcp_listen(const char *host, const char *serv, socklen_t *addrlenp) {
  int listenfd, n;
  const int on = 1;
  struct addrinfo hints, * res, * ressave;

  bzero(&hints, sizeof(struct addrinfo));
  hints.ai_flags = AI_PASSIVE;
  hints.ai_family = AF_UNSPEC;
  hints.ai_socktype = SOCK_STREAM;

  if ((n = getaddrinfo(host, serv, &hints, &res)) != 0)
    err_quit("tcp_listen error for %s , %s : %s", host, serv, gai_strerror(n));
  ressave = res;

  do {
    listenfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
    if (listenfd < 0) continue; // error, try next one

    Setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)); // 防止端口已有链接存在
    if (bind(listenfd, res->ai_addr, res->ai_addrlen) == 0) break; // success
    Close(listenfd); // bind error ,close and try next one
  } while ((res = res->ai_next) != NULL);

  if (res == NULL) err_sys("tcp listen error for %s , %s", host, serv);
  Listen(listenfd, LISTENQ);
  if (addrlenp) *addrlenp = res->ai_addrlen; // return size of protocol address
  freeaddrinfo(ressave);

  return listenfd;
}

    例子1：时间获取服务器程序

#include "unp.h"
#include <time.h>

int main(int argc, char const *argv[]) {
  int listenfd, connfd;
  socklen_t len;
  char buff[MAXLINE];
  time_t ticks;
  struct sockaddr_storage cliaddr;

  if (argc != 2) err_quit("usage : daytimetcpsrv1 <service or port #>");
  listenfd = Tcp_listen(NULL, argv[1], NULL);

  while(1){
    len = sizeof(cliaddr);
    connfd = Accept(listenfd, (SA *)&cliaddr, &len);
    printf("connection from %s\n", Sock_ntop_host((SA *)&cliaddr, len));

    ticks = time(NULL);
    snprintf(buff, sizeof(buff), "%.24s\r\n", ctime(&ticks));
    Write(connfd, buff, strlen(buff));
    Close(connfd);
  }
  return 0;
}

    该程序存在一个小问题， tcp_listen的第一个参数是一个空指针，而且tcp_listen函数内部指定的地址族AF_UNSPEC ,两者结合可能导致getaddrinfo返回非期望地址族的套接字地址结构。
    举例来说，在双栈主机上返回的第一个套接字地址结构将是IPv6的，但我们期望该服务器仅仅处理IPV4.
    例子2：可指定协议的时间获取服务器程序

#include "unp.h"
#include <time.h>
int main(int argc, char const *argv[]) {
  int listenfd, connfd;
  socklen_t len, addrlen;
  char buff[MAXLINE];
  time_t ticks;
  struct sockaddr_storage cliaddr;

  if (argc == 2) listenfd = Tcp_listen(NULL, argv[1], &addrlen);
  else if (argc == 3) listenfd = Tcp_listen(argv[1], argv[2], &addrlen);
  else err_quit("usage : daytimetcpsrv2 [<host>] <sevice or port>");

  while (1) {
    len = sizeof(cliaddr);
    connfd = Accept(listenfd, (SA *)&cliaddr, &len);
    printf("connection from %s\n", Sock_ntop_host((SA *)&cliaddr, len));

    ticks = time(NULL);
    snprintf(buff, sizeof(buff), "%.24s\r\n", ctime(&ticks));
    Write(connfd, buff, strlen(buff));

    Close(connfd);
  }
  return 0;
}

udp_client

    udp_client： 用于创建未连接的 UDP 套接字。

#include "unp.h"
int udp_client(const char * hostname,const char * service,struct sockaddr ** saptr,socklen_t * lenp);
// 若成功则为未连接套接字描述符，若出错则不返回

int udp_client(const char *host, const char *serv, SA **saptr, socklen_t *lenp) {
  int sockfd, n;
  struct addrinfo hints, *res, *ressave;

  bzero(&hints, sizeof(struct addrinfo));
  hints.family = AF_UNSPEC;
  hints.ai_socktype = SOCK_DGRAM;
  // 这里获取的起始是服务器的IP和端口,而次函数的功能为,返回服务器套接字结构地址和本地套接字
  if ((n = getaddrinfo(host, serv, &hints, &res)) != 0)
    err_quit("udp_client erorr for %s, %s : %s", host, serv, gai_strerror(n));
  ressave = res;

  do {
    // 对于UDP套接字是可以不绑定的端口的,在第一次调用sendto的时候由内核指定一个临时端口
    sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
    if (sockfd >= 0) break;
  } while ((res = res->ai_next) != NULL);

  if (res == NULL) err_sys("udp_client error for %s , %s", host, serv);
  *saptr = Malloc(res->ai_addrlen);
  memecpy(*saptr, res->ai_addr, res->ai_addrlen);
  *lenp = res->ai_addrlen;
  freeaddrinfo(ressave);
  return (sockfd);
}

    例子：协议无关时间获取客户程序

#include "unp.h"

int main(int argc, char const *argv[]) {
  int sockfd, n;
  char recvline[MAXLINE + 1];
  socklen_t salen;
  struct sockaddr * sa;

  if (argc != 3) err_quit("usage : daytimeudpcli1 <hostname/IPaddress> <service/port#>");

  sockfd = Udp_client(argv[1], argv[2], (void **)&sa, &salen);
  printf("sending to %s\n", Sock_ntop_host(sa, salen));

  Sendto(sockfd, "", 1, 0, sa, salen); // send 1 byte datagram
  n = Recvfrom(sockfd, recvline, MAXLINE, 0, NULL, NULL);
  recvline[n] = '\0';
  Fputs(recvline, stdout);
  return 0;
}

udp_connect

    该函数创建一个已连接UDP套接字

#include "unp.h"
int udp_connect(const char *hostname,const char * service);
// 返回：若成功则为以连接套接字描述符，若出错则不返回

int udp_connect(const char *host, const char *serv) {
  int sockfd, n;
  struct addrinfo hints, * res, * ressave;

  bzero(&hints, sizeof(struct addrinfo));
  hints.ai_family = AF_UNSPEC;
  hints.ai_socktype = SOCK_DGRAM;

  if ((n = getaddrinfo(host, serv, &hints, &res)) != 0)
    err_quit("udp_connect error for %s, %s : %s", host, serv, gai_strerror(n));
  ressave = res;

  do { 
    sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
    if (sockfd < 0) continue;
    if (connect(sockfd, res->ai_addr, res->ai_addrlen) == 0) break;
    Close(sockfd);
  } while ((res = res->ai_next) != NULL);

  if (res == NULL) err_sys("udp_connect error for %s, %s ", host, serv);
  freeaddrinfo(ressave);
  return sockfd;
}

udp_server

#include "unp.h"
int udp_server(const char *hostname,const char *service,socklen_t *lenptr);
// 返回：若成功则为以连接套接字描述符，若出错则不返回

int udp_server(const char *host, const char *serv, socklen_t *addrlenp) {
  int sockfd, n;
  struct addrinfo hints, * res, * ressave;

  bzero(&hints, sizeof(struct addrinfo));
  hints.ai_flags = AI_PASSIVE;
  hints.ai_family = AF_UNSPEC;
  hints.ai_socktype = SOCK_DGRAM;

  if ((n = getaddrinfo(host, serv, &hints, &res)) != 0)
    err_quit("udp_server error for %s, %s : %s", host, serv, gai_strerror(n));
  ressave = res;

  do {
    sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
    if (sockfd < 0) continue;
    if (bind(sockfd, res->ai_addr, res->addrlen) == 0) break;
    Close(sockfd);
  } while ((res = res->ai_next) != NULL);

  if (res == NULL) err_sys("udp_server error for %s, %s ", host, serv);
  if (addrlenp) *addrlenp = res->ai_addrlen;
  freeaddrinfo(ressave);
  return sockfd;
}

    例子：协议无关时间获取服务器程序

#include	"unp.h"
#include	<time.h>
int main(int argc, char **argv){
	int			sockfd;
	ssize_t			n;
	char			buff[MAXLINE];
	time_t			ticks;
	socklen_t		len;
	struct sockaddr_storage	cliaddr;

	if (argc == 2)
		sockfd = Udp_server(NULL, argv[1], NULL);
	else if (argc == 3)
		sockfd = Udp_server(argv[1], argv[2], NULL);
	else
		err_quit("usage: daytimeudpsrv [ <host> ] <service or port>");

	for ( ; ; ) {
		len = sizeof(cliaddr);
		n = Recvfrom(sockfd, buff, MAXLINE, 0, (SA *)&cliaddr, &len);
		printf("datagram from %s\n", Sock_ntop((SA *)&cliaddr, len));

		ticks = time(NULL);
		snprintf(buff, sizeof(buff), "%.24s\r\n", ctime(&ticks));
		Sendto(sockfd, buff, strlen(buff), 0, (SA *)&cliaddr, len);
	}
}

getnameinfo

    该函数是getaddrinfo的互补函数，它以一个函数套接字地址为参数，返回描述其中的主机的一个字符串和描述其中服务的另一个字符串。该函数以协议无关的方式提供这些信息。

#include <netdb.h>
int getnameinfo(const struct sockaddr *sockaddr,socklen_t addrlen,char *host,socklen_t hostlen,char * serv,socklen_t servlen,int flags);
// 返回：若成功则为0，若出错则为非0

    参数:
        sockaddr和addrlen指定一个套接字地址结构，此套接字地址结构包含待转换成直观可读的字符串的协议地址.
        host和hostlen指定主机字符串(由调用者预先分配存储空间)(调用者不想返回主机字符串，那就指定hostlen为0)
        serv和servlen指定服务字符串(由调用者预先分配存储空间)(调用者不想返回服务字符串，那就指定servlen为0)
    sock_ntop 和 getnameinfo 的差别在于，前者不涉及DNS，只返回IP 地址和端口号的一个可显示版本,后者通常尝试获取主机和服务的名字。
    getnameinfo函数6个可指定的标志：

常值			说明
NI_DGRAM		数据报服务
NI_NAMEREQD		若不能从地址解析出名字则返回错误
NI_NOFQDN		只返回 FQDN 的主机名部分
NI_NUMERICHOST	以数串格式返回主机字符串
NI_NUMERICSCOPE	以数串格式返回范围标识字符串
NI_NUMERICSERV	以数串格式返回服务字符串
可重入函数

    查看本章讲解的名字和地址转换函数以及第4章中的inet_XXX函数，我们就重入函数提请注意以下几点:
    一些重用相关函数:
        因历史原因, gethostbyname, gethostbyname, getservbyname, getservbyport 这4个函数是不可重入的，因为他们都返回指向同一个静态结构的指针
        inet_pton,inet_ntop总是可重入的
        因历史原因，inet_ntoa是不可重入的，不过支持线程的一些实现提供了使用线程特定数据的可重入版本
        getaddrinfo 可重入的前提是它调用的函数都是可重入的，这就是说，他应该调用可重入版本的 gethostbyname和getservbyname。该函数返回的结果全部存放在动态分配内存空间的原因之一就是允许它可重入。
        getnameinfo可重入的前提是它调用的函数都是可重入的，这就是说，他应该调用可重入版本的 gethostbyaddr和getservbyport
    errono变量存在类似的问题： 首先因该注意若没有任何错误发生则errno的值不会改变。因此，除非知道发生了一个错误，否则不应该查看errno的值。

gethostbyname_r

int gethostbyname_r(const char *name,
               struct hostent *ret, char *buf, size_t buflen,
               struct hostent **result, int *h_errnop);
// 返回：若成功则为非空指针，若出错则为NULL

gethostbyaddr_r

int gethostbyaddr_r(const void *addr, socklen_t len, int type,
               struct hostent *ret, char *buf, size_t buflen,
               struct hostent **result, int *h_errnop);
// 返回：若成功则为非空指针，若出错则为NULL		

其它网络相关信息

    我们在本章中一直关注主机名和IP地址以及服务名和端口号。然而我们的视野可以更广阔，应用程序可能想要查找四类与网络相关的信息：主机、网络、协议、服务。
        大多数查找针对的是主机(gethostbyname和 bethostbyaddr),
        一小部分查找针对的是服务(getservbyname和getservbyport),
        更小一部分查找针对的是网络和协议

    所有四类信息都可以存放在一个文件中，每类信息各定义有三个访问函数：
        函数 getXXXent 读出文件中的下一个表项，必要的话首先打开文件。
        函数 setXXXent 打开(如果尚未打开的话) 并回绕文件。
        函数 endXXXent 关闭文件。

    每类信息都定义了各自的结构，包括 hostent,netent,servent. 都由 <netdb.h> 提供

    除了顺序处理文件 get、set、end这三个函数外，每类信息还提供一些键值查找函数。这些函数顺序遍历整个文件(通过调用 getXXXent函数读出每一行)，并寻找与某个参数匹配的一个表项。这些键值查找函数具有形如 getXXXbyYYY 的名字。

    四类网络相关信息：

信息	数据文件		结构		键值查找函数
主机	/etc/hosts	hostent		gethostbyaddr,gethostbyname
网络	/etc/networks	netent		getnetbyaddr, getnetbyname
协议	/etc/protocols	protoent	getprotobyname, getprotobynumber
服务	/etc/services	servent		getservbyname, getservbyport

    在使用DNS的前提下如何应用这些函数呢？首先只有主机和网络信息可以通过DNS获取，协议和服务信息总是从相应的文件中读取。
    我们之前有提到过，不同的实现有不同的方法供系统管理员指定是使用DNS还是使用文件来查找主机和网络信息。

    其次，如果使用DNS查找主机和网络信息，那么只有键值查找函数才有意义。举例来说，你不能使用gethostent并期待顺序遍历DNS中所有表项。
    如果调用gethostent,那么它仅仅读取/etc/hosts文件并避免访问DNS。

    注：虽然网络信息可以做成通过DNS能够访问到，但是很少有人这么做。

第12章 IPv4和IPv6的互操作性
12.1 概述

    未来，因特网会逐渐从IPv4转换到IPv6所以应用程序能够对两种协议协同工作是很重要的，我们将讨论IPv4应用如何与IPv6进行通信

12.2 IPv4 客户与 IPv6 服务器

    双栈主机一个很重要的特性就是技能处理IPv4又能处理IPv6客户。这是通过使用IPv4映射的IPv6地址来实现的
    主机使用IPv6服务器，收到IPv4的帧时，会将源IPv4地址转换为一个映射的IPv6地址
        IPv4 地址可以转换为一个唯一的IPv6 地址(IPv4地址补齐到IPv6地址格式, 方式是在前补::ffff)
        然后把数据报相应的字段给替换掉(包括IP版本标识字段)

    补充 IPv6 地址格式
    IPv6中的双冒号:
        通过使用双冒号(::)替换一系列零来指定 IPv6 地址, 一个IP 地址中只可使用一次双冒号。
            例如: IPv6 地址: ff06:0:0:0:0:0:0:c3 可写作 ff06::c3。
    IPv4映射的IPv6地址使用此替代格式。
        此类型的地址用于将IPv4节点表示为IPv6地址。
            例如: IPv4地址192.1.56.10映射为IPv6地址0:0:0:0:0:ffff:192.1.56.10和 ::ffff:192.1.56.10/96(短格式)
    注意IPv6地址不能直接转IPv4地址

    一个IPv4客户端和IPv6服务端通信地步骤如下：
        IPv6服务器启动后创建一个IPv6监听套接字
        IPv4客户调用getsockname找到服务器地A记录。服务器既有A也有AAAA记录，因为它是双栈的
        客户调用connect，发送一个IPv4的SYN给服务器
        服务器收到这个SYN，把它标志为IPv4映射为IPv6，响应一个IPv4 SYN/ACK。连接建立后， 由accept返回给服务器的地址就是这个IPv4映射的IPv6地址
        当服务器向这个客户端发送数据时，会使用客户端的IPv4地址，所以通信使用的全部都是IPv4连接
        如果服务器不检查这个地址是IPv6还是IPv4映射过来，它永远不会知道客户端的 IP 类型，客户端也不需要知道服务器的类型
    大多数双栈主机遵循以下规则：
        IPv4 监听套接字只能接受来自IPv4 客户的外来连接
        如果服务器有一个绑定了IPv6 的监听套接字，该套接字没设置 IPV6_V6ONLY 套接字选项，它可以接收 IPv4 连接
        如果服务器有一个 IPv6 监听套接字，绑定了通配地址，该套接字设置了 IPV6_V6ONLY 套接字选项，它只能接收 IPv6 连接
        TCP IPv4 客户与 IPv6 服务器
    IPv6 UDP服务器的情况与之类是, 差别在于数据报的地址格式有所不同.例如IPv6服务器收到来自某个IPv4客户的数据报,recvfrom返回的地址将是该客户端的IPv6地址(由于IPv4映射而来)

12.3 IPv6客户与IPv4服务器

    客户机运行在双栈主机上并使用IPv6套接字描述符
    过程:
        一个IPv4 服务器在只支持IPv4的主机上启动一个IPv4 监听套接字
        IPv6 客户启动后调用getaddrinfo单纯查找IPv6的地址，因为服务器只支持IPv4，所以返回给客户端的是一个IPv4映射的IPv6地址
        IPv6 客户在作为函数参数的 IPv6 套接字地址结构中设置这个 IPv4 映射的 IPv6 地址然后调用 connect。内核检测到这个映射地址后自动发送一个IPv4 SYN到服务器
        服务器响应一个IPv4 SYN/ACK，连接于是通过使用IPv4 数据报建立

12.2-12.3 互操作性总结

    IPv4客户端与IPv6服务器(双栈)
        套接字接受数据报分析:
            对于IPv4套接字它只能接受IPv4数据报(IPv6地址不能映射为IPv4地址)
            对于IPv6套接字(带双栈)它可以接受IPv4数据报和IPv6数据报(IPv4地址可以被唯一映射为IPv6地址)
        具体分析: 如果目的地为IPv6套接字的IPv4数据报,那么内核(目的地内核)把该数据包的源IPv4地址映射为IPv6地址作为accept(TCP)或recvfrom(UDP)返回的对端IP地址
        IPv4客户端与IPv6服务器
    IPv4服务器与IPv6客户端(双栈)
    套接字发送数据报分析:
        IPv4数据报可以接受IPv4套接字和IPv6套接字的数据发送(IPv6套接字的目的地为由IPv4地址映射的IPv6地址是内核将其转变为IPv4数据报)
        IPv6数据报只能接受IPv6套接字的数据发送
    IPv4套接字不能发送一个IPv6数据报,因为不可能往IPv4套接字上设置IPv6地址,毕竟IPv4套接字接受的sockaddr_in的in_addr成员只有4字节的长度
    当IPv6套接字发送数据时,内核检测到目的IP地址为由IPv4地址映射的IPv6地址,所以此地址转换为IPv4地址发送IPv4数据报
    IPv4服务器与IPv6客户端(双栈)

IPv6地址测试宏

    有一些 IPv6 应用必须知道和它通信的是 IPv6 还是 IPv4 协议，使用 <netinet/in.h> 中的函数可以进行测试
    int IN6_IS_ADDR_V4MAPPED(const struct in6_addr *aptr)宏测试IPv6地址是否由IPv4映射而来

源代码可移植性

    考虑到源码的可移植性，编写代码时应尽量避免 gethostbyname, gethostbyaddr等套接字函数，使用 getaddrinfo, getnameinfo等函数，使得代码变得与协议无关。

小结

    双栈主机的IPv6 服务器可以和两种客户端进行通讯, 对于IPv4客户端使用IPv4数据报进行通信
    双栈主机的IPv6 客户端也可以和两种服务器进行通讯, 对于IPv4服务器使用IPv4数据报进行通信

第13章：守护进程和inetd超级服务器

13.1 概述

        守护进程：是在后台运行且不与任何控制终端关联的进程。Unix系统通常有很多守护进程在后台运行(通常为20~50个的数量级)执行不同的管理任务.
        守护进程没有终端，通常是因为他们由开机时的脚本进行启动。守护进程也可能从某个终端由用户在shell提示符下键入命令行进行启动，
        这样的守护进程必须亲自脱离与控制终端的关联，从而避免与作业控制终端, 会话管理，终端产生信号等发生不希望的交互,也防止后台的守护进程输出到终端

    守护进程的启动方式：
        在系统阶段进行启动，许多守护进程由系统初始化脚本进行启动，脚本通常位于 /etc 等目录，这些脚本启动的守护进程开始就拥有超级用户权限（inetd，Web，sendmail，syslogd 等等）
        许多网络服务器由 inetd超级服务器(其本身由第一条启动) 进行启动。Inetd监听网络请求，每当有一个请求到达，启动相应的实际服务器(Telnet，FTP…)
        cron守护进程(其本身由第一条启动) 按规则定期执行一些程序,这些程序同样作为守护进程运行
        at 命令用于指定将来某个时刻的程序执行，时间到达时，通常使用corn来进行执行
        守护进程还可以从用户的终端在前台或者后台进行启动。这么做往往是测试守护进程或者重启关闭的守护进程。
    因为守护进程没有终端，所以他们的消息使用 syslog 函数，将消息发送给 syslogd 进程

13.2 syslodg守护进程

    syslogd守护进程通常由系统初始化脚本进行启动，并在系统工作时间一直运行，启动步骤如下：
        读取配置文件，在 /etc/syslog.conf 配置文件指定守护进程收取的各种日志消息应如何处理。可能添加到一个文件中，或被写到用户的登录窗口，或被转发给另一个主机上的 syslogd 进程
        创建 Unix 域数据报套接字，给它捆绑路径名 /var/run/log
        创建 UDP 套接字，捆绑 514 端口，接收别的主机发送过来的日志
        打开路径名 /dev/klog。来自内核的任何出错消息从这个设备输入
        syslog 使用 select 来监听上面 2，3，4 步的描述符来接受日志，并按照配置文件进行处理。如果守护进程读取 SIGHUP 信号，就重新读取配置文件
    最新的系统不建议开启 514 端口，会遭到攻击

13.3 syslog

    守护进程没有终端，所以不能把消息 fprintf 到 stderr 上。从守护进程中登记消息的常用技巧是调用 syslog 函数
    logger 命令在 shell 脚本中以向 syslogd 发送消息

#include <syslog.h>
void syslog(int priority, const char * format, ...);

    参数解析：
        priority：级别(level)和设施(facility)两者的组合体
        format：类似 printf 格式串，增加了 %m 规范代表当前 errno 值
    当 syslog 被应用进程首次调用时，它创建一个 Unix 域数据报套接字，然后调用 connect 连接到由 syslogd 守护进程创建的 Unix 域数据报套接字的众所周知的路径名。
    这个套接字一直打开，直到进程终止关闭. 可以在syslog使用前调用openlog,在不需要发送日志时,调用closelog(注意openlog并不会立即创建套接字,除非指定NDELAY选项)
        void openlog(const char *ident, int options, int facility);
        void closelog(void);
        参数
            ident是一个由syslog冠名的每个日志消息之前的字符串,通常是程序的名字
            options有多和常值的逻辑构成

optiions	说明
LOG_CONS	若无法发送到syslogd守护进程则登记到控制台
LOG_NDELAY	不延迟打开,立即创建套接字
LOG_PERROR	即发送到syslogd守护进程,又发送到标准错误输出
LOG_PID	随每个日志消息登记进程ID

    日志消息的level

level		值	说明
LOG_EMERG	0	系统不可用(最高优先级)
LOG_ALERT	1	必须立即采取行动
LOG_CRIT	2	临界条件
LOG_ERR	3	出错条件
LOG_WARNING	4	警告条件
LOG_NOTICE	5	正常然而重要的条件(默认值)
LOG_INFO	6	通告消息
LOG_DEBUG	7	调试级消息(最低优先级)

    标识消息发送进程类型的facility

facility	说明
LOG_AUTH	安全/授权消息
LOG_AUTHPRIV	安全/授权消息(私用)
LOG_CRON	cron守护进程
LOG_DAEMON	西东守护进程
LOG_FTP	FTP守护进程
LOG_KERN	内核消息
LOG_LOCAL0	本地消息
LOG_LOCAL1	本地消息
LOG_LOCAL2	本地消息
LOG_LOCAL3	本地消息
LOG_LOCAL4	本地消息
LOG_LOCAL5	本地消息
LOG_LOCAL6	本地消息
LOG_LOCAL7	本地消息
LOG_LPR	行式打印机系统
LOG_MAIL	邮件系统
LOG_NEWS	网络新闻系统
LOG_SYSLOG	由syslogd内部产生的消息
LOG_USER	任意的用户级消息(默认)
LOG_UUCP	UUCP系统

    例如,当rename函数调用失败时,守护进程执行以下调用:
        syslog(LOG_INFO|LOG_LOCAL2, "RENAME(%s,%s): %m", file1, file2);

13.4 daemon_init

    编写一个守护进程的创建函数，有些系统(如Linux)提供 daemon 函数用来创建守护进程，和本程序类似
    守护进程在没有终端的环境下运行，不会接收 SIGHUP 信号。许多守护进程把这个信号可以当作系统发送的通知，表示配置文件发送了变化，应重新读取配置文件，类似的还有 SIGINT SINGWINCH信号

#include	"unp.h"
#include	<syslog.h>
#define		MAXFD	64
extern int	daemon_proc;	/* defined in error.c */
int daemon_init(const char *pname, int facility){
	int	i;
	pid_t	pid;
    // 调用 fork 创建子进程，然后直接终止父进程，留下子进程继续执行。
    // 如果是在 shell 中执行的程序，父进程终止，shell 会认为程序已经结束了，子进程就可以在后台执行了
    // 子进程继承父进程的进程组 ID，但它有自己的进程 ID，这就保证了子进程不是一个进程组的头进程，这是接下来调用 setsid 的必要条件
	if ( (pid = Fork()) < 0)
		return (-1);
	else if (pid)
		_exit(0);			/* parent terminates */

	/* child 1 continues... */
    // setsid 用来创建一个新的会话。当前进程变为新会话的会话头进程以及新进程组的进程组头进程，从而不再有控制终端
	if (setsid() < 0)			/* become session leader */
		return (-1);
    // 忽略 SIGHUP 信号，并再次调用 fork。该函数返回时，同样只使用子进程，父进程返回
    // 再次 fork 是为了确保本守护进程将来即使打开一个新的终端，也不会自动获得控制终端。
    // 当没有终端的一个会话头进程打开终端时，该终端自动成为这个头进程的控制终端。
    // 再次调用 fork，产生的子进程不是会话头进程，就不会自动获得一个控制终端。
    // 这里必须忽略 SIGHUP 信号，当会话头进程终止时，所有会话子进程都会收到 SIGHUP 信号
	Signal(SIGHUP, SIG_IGN);
	if ( (pid = Fork()) < 0)
		return (-1);
	else if (pid)
		_exit(0);			/* child 1 terminates */

	/* child 2 continues... */
    // 把全局变量 daemon_proc 设置为非 0 值，这个变量由 err_XXX 函数使用，不为 0 是为了告诉他们将 fprintf 输出替换为调用 syslog 函数
	daemon_proc = 1;			/* for err_XXX() functions */
    // 改变工作目录到根目录
	chdir("/");				/* change working directory */

	/* close off file descriptors */
    // 关闭所有打开的描述符，直接关闭前 64 个，这里不考虑太多
	for (i = 0; i < MAXFD; i++)
		close(i);

	/* redirect stdin, stdout, and stderr to /dev/null */
    // 将 stdin stdout stderr 重定向到 /dev/null
	open("/dev/null", O_RDONLY);
	open("/dev/null", O_RDWR);
	open("/dev/null", O_RDWR);
    // 使用 syslogd 处理错误
	openlog(pname, LOG_PID, facility);

	return (0);				/* success */
}

    例子:时间服务器做守护进程

#include "unp.h"
#include <time.h>
int mian(int argc, char **argv){
	int listenfd, connfd;
	socklen_t addrlen, len;
	struct sockaddr *cliaddr;
	char buff[MAXLINE];
	time_t ticks;
	if(argc <2 || arc > 3) err_quit("usage: dayimetcpsrv2 [ <host> ] <service or port>");
	daemon_init(argv[0], 0);
	if(argc ==2) Tcp_listen(NULL, argc[1], &addrlen);
	else Tcp_listen(argc[1], argc[2], &addrlen);
	cliaddr = Malloc(addrlen);
	while(1){
		len = addrlen;
		connfd = Accept(listenfd, cliaddr, &len);
		err_msg("connect from %s", Sock_ntop(cliaddr, len));
		ticks = time(NULL);
		snprintf(buff, sizeif(buff), "%.24s\r\n", ctime(&ticks));
		Write(connfd, buff, strlen(buff));
		Close(connfd);
	}
}

13.5 inetd守护进程

        Unix系统中可能存在很多服务器,他们只是等待客户请求的到达,如FTP, Telnet, Rlogin等等. 这些进程都是在系统自举阶段从/etc/rc文件中启动,而且每个进程执行几乎相同的启动任务: 
        创建一个套接字,把本服务器的监听端口绑定到套接字上,等待客户连接,然后派生子进程.子进程为客户提供服务.
        交给 inetd 守护进程来进行处理，既可以简化编写的代码，又可以对每次客户端的请求单独响应，并不需要每个服务器一直等待客户端，因为他们大多数时间都处于休眠状态。
        只需要 inetd 循环等待客户端的请求即可，来了请求，为对应的客户创建需要的服务器子进程即可。

    这个模型存在的问题:
        所有的这些守护进程几乎有相同的启动代码,如创建套接字以及升级为守护进程
        这些进程大部分时间都处于休眠状态

    使用因特网超级服务器(inetd守护进程)使上述问题得到简化:
        将inetd升级为守护进程
        inetd循环等待客户端的请求即可，来了请求，为对应的客户创建需要的服务器子进程即可.

    inetd首先把自己升格为守护进程,然后读入并处理配置文件(通常是/etc/inetd.conf)该文件每一行的字段如下:

    inetd.conf文件中的子段

字段				说明
service-name			必须在/etc/services文件中定义
socket-type			stream(对于TCP)活dgram(对于UDP)
protocal				必须在/etc/protocals文件中定义: TCP/UDP
wait-flag			对于TCP一般为nowait, 对于UDP一般为wait
login-name			来自/etc/passwd的用户名,一般为root
server-program			调用exec指定的完整路径名
server-program-arguments	调用exec指定的命令行参数

    例如(标题是为了方便理解添加的):

service-name	socket-type	protocal	wait-flag	login-name	server-program	server-program-arguments
ftp		stream		tcp	nowait		root		/usr/bin/ftpd	ftpd -l
telnet		stream		tcp	nowait		root		/usr/bin/telnetd	telnetd
login		steam		tcp	nowait		root		/usr/bin/rlogind	rlogind -s
tftp		dgram		udp	wait		nobody		/usr/bin/tftpd	tftpd -s /tftpboot

    当使用 inetd 调用exec指定某一个服务器程序时，该服务器的真实名字总是作为程序的第一个参数传递
    inetd的工作流程
    inetd 工作流程(数据包服务:nowait)
        启动阶段，读取配置文件，并给文件中每个类型服务器创建一个适当的类型（TCP or UDP…）的套接字。inetd 能够处理的服务器最大个数取决于 inetd 能够创建的描述符最大个数，使用 select 对所有描述符进行集中
        为每个套接字调用 bind，指定 IP + port。端口通过 getservbyname 获取
        对于 TCP 套接字，调用 listen 来进行监听，UDP 不用执行
        使用 select 对所有套接字描述符进行监听，inetd 大部分时间都花在这里
        如果可读的是 TCP 套接字描述符，调用 accept 来进行连接
        调用 fork 创建子进程来处理不同的请求，类似于并发服务器
        如果第5步返回字节流套接字，父进程要关闭已连接套接字，就是accept的套接字，类似于TCP并发服务器
    ined工作流程(数据包服务:wait)与数据包nowait的差异, 对于数据报服务指定为wait标志导致父进程执行步骤发生变化. 这个标志要求inetd必须在这个套接字再次成为select调用的候选套接字之前等待当前服务该套接字的子进程终止.
        fork返回到父进程时,父进程保存子进程的ID. 这么做使得父进程能够通过查看由waitpid返回的值确定这个子进程的终止时间
        父进程通过使用FD_CLR宏关闭这个套接字在select所在描述符集对应位,达成在将来select调用中禁止这一套接字的目的.
        当子进程终止时, 父进程被通知以一个SIGCHLD信号,而父进程的信号处理函数将取得该子进程的进程ID父进程随即打开套接字在select所在描述符集中对应位,使得此套接字重新成为select的候选套接字

13.6 daemon_inetd

    该函数可以用在 inetd 启动的服务器程序中

#include	"unp.h"
#include	<syslog.h>
extern int	daemon_proc;	/* defined in error.c */
void daemon_inetd(const char *pname, int facility){
	daemon_proc = 1;		/* for our err_XXX() functions */
	openlog(pname, LOG_PID, facility);
}

    所有的步骤已经由 inetd 在启动时执行完毕，本函数仅仅处理错误函数设置 daemon_proc 标志，并调用 openlog 函数
    由 inetd 作为守护进程启动时间获取服务器程序

#include	"unp.h"
#include	<time.h>
int main(int argc, char **argv) {
	socklen_t		len;
	struct sockaddr	*cliaddr;
	char			buff[MAXLINE];
	time_t			ticks;
	daemon_inetd(argv[0], 0);

	cliaddr = Malloc(sizeof(struct sockaddr_storage));
	len = sizeof(struct sockaddr_storage);
	Getpeername(0, cliaddr, &len); // 因为inetd会关闭除accept返回套接字的所有其他描述符,然后把返回套接字复制至 0(标准输入),1(标准输出),2(标准错误)
	err_msg("connection from %s", Sock_ntop(cliaddr, len));

    ticks = time(NULL);
    snprintf(buff, sizeof(buff), "%.24s\r\n", ctime(&ticks));
    Write(0, buff, strlen(buff));

	Close(0);	/* close TCP connection */
	exit(0);
}

    小结
        守护进程是在后台运行并独立与所有终端的进程，许多网络服务器作为守护进程运行。守护进程所产生的输出调用 syslog 函数交给 syslogd 守护进程处理
        启动任意一个程序并将其变为守护进程步骤如下：
            调用 fork 到后台运行
            调用 setsid 创建一个新会话，并让前一步的子进程成为会话头进程
            再次 fork 防止会话头进程自动获取控制终端(当没有终端的一个会话头进程打开终端时，该终端自动成为这个头进程的控制终端。再次调用 fork，产生的子进程不是会话头进程，就不会自动获得一个控制终端)
            改变工作目录
            创建模式掩码(???)
            关闭所有非必要描述符
            许多 Unix 服务器由 inetd 守护进程启动。它处理所有守护进程需要的步骤，当启动真正的服务器时，套接字已在标准输入，标准输出，标准错误上打开。这样就不用调用 socket，bind，accept，这些步骤已经由 inetd 完成。

第14章：高级IO函数
14.1 概述

    本章讨论 I/O 的高级操作，首先是在 I/O 上设置超时，这里有三种方法。
    然后是 read 和 write 的三个变体：
        recv 和 send 允许通过第四个参数从进程到内核传递标志
        readv 和 writev 允许指定往其中输入数据或从其中输出数据的缓冲区向量
        recvmsg 和 sendmsg 结合了其他 I/O 函数的所有特性，并具备接收和发送辅助数据的新能力

14.2 套接字超时

    设置超时的方法有 3 种：
        调用 alarm，它在指定超时期满时产生 SIGALRM 信号。这个方法涉及信号处理，而信号处理在不同的实现上存在差异，而且可能干扰进程中现有的 alarm 调用
        在 select 中阻塞等待 I/O（select 有内置时间限制）以此代替直接阻塞在 read 或 write 调用上
        使用较新的 SO_RCVTIMEO 和 SO_SNDTIMEO 套接字选项。这个方法的问题在于并非所有实现都支持这两个套接字选项。
    上述三个技术都适用于输入和输出操作（例如 read，write 以及诸如 recvfrom，sendto 之类），不过我们依然期待可用于 connect 的技术，因为 TCP 内置的 connect 超时相当长。
    select可用来在 connect 上设置超时的先决条件是相应套接字处于非阻塞模式，而那两个套接字选项对 connect 并不适用。
    我们还指出，前两个技术使用于任何描述符，而第三个技术仅仅适用于套接字描述符（因为是套接字描述符选项）

使用 SIGALRM 为 connect 设置超时

    本方法仅能减少 connect 的超时，但不能增加 connect 的超时设置，因为 connect 有自己的超时设置(例如先有内核的超时时长为75s, 如果我们调用函数设置10s(小于原时长的值), 都是行得通的,但是当设置为80s(大于原时长的值),则会失败,依旧在75s(等于原时长)时发生超时)
    需要注意的是在多线程中使用信号非常困难，建议仅仅在未线程化或仅在单线程中使用本技术

static void	connect_alarm(int);
int connect_timeo(int sockfd, const SA *saptr, socklen_t salen, int nsec){
	Sigfunc	*sigfunc;
	int		n;
    // 设置 SIGALRM 信号的处理函数，并保存原有的处理函数到 sigfunc
	sigfunc = Signal(SIGALRM, connect_alarm);
    // 设置报警时钟的秒数，返回值是上一次设置的剩余秒数，没有就返回 0
	if (alarm(nsec) != 0) err_msg("connect_timeo: alarm was already set");
    // connect 为慢调用,当被终端打断时,就会发出返回,并置 errno 为EINTR
    // 调用 connect，调用中断就设置 error 设置为 TIMEOUT，并关闭套接字，防止三路握手继续进行
	if ( (n = connect(sockfd, saptr, salen)) < 0) {
		close(sockfd);
		if (errno == EINTR) errno = ETIMEDOUT; 
	}
    // 关闭报警时钟，并恢复原处理函数
	alarm(0);					/* turn off the alarm */
	Signal(SIGALRM, sigfunc);	/* restore previous signal handler */
	return(n);
}

// 信号函数仅仅返回
static void connect_alarm(int signo)
{
	return;		/* just interrupt the connect() */
}

使用 SIGALRM 为 recvfrom 设置超时

    本例子工作正常,因为每次读取alarm设置报警时钟之后,期待读取的只是单个应答

static void	sig_alrm(int);
void dg_cli(FILE *fp, int sockfd, const SA *pservaddr, socklen_t servlen){
	int	n;
	char	sendline[MAXLINE], recvline[MAXLINE + 1];
	Signal(SIGALRM, sig_alrm); // 为什么保留原来的中断处理函数,结束后也没有恢复

	while (Fgets(sendline, MAXLINE, fp) != NULL) {
		Sendto(sockfd, sendline, strlen(sendline), 0, pservaddr, servlen);
        // 调用 recvfrom 函数前设置了 5 秒的超时设置
		alarm(5);
		if ( (n = recvfrom(sockfd, recvline, MAXLINE, 0, NULL, NULL)) < 0) {
			if (errno == EINTR)
				fprintf(stderr, "socket timeout\n");
			else
				err_sys("recvfrom error");
		} else {
            // 读取数据，关闭超时处理
			alarm(0);
			recvline[n] = 0;	/* null terminate */
			Fputs(recvline, stdout);
		}
	}
}
// 简单返回，用来中断阻塞的 ercvfrom 调用
static void sig_alrm(int signo)
{
	return;			/* just interrupt the recvfrom() */
}

使用 select 为 recvfrom 设置超时

    该函数中 select 指定等待描述符的最长时间

int readable_timeo(int fd, int sec)
{
	fd_set		rset;
	struct timeval	tv;
    // 准备 select 参数
	FD_ZERO(&rset);
	FD_SET(fd, &rset);

	tv.tv_sec = sec;
	tv.tv_usec = 0;
    // 调用有超时的 select 函数，出错返回 -1，超时返回 0
    // 本来select 还应该更具返回值判断是属于那个标志位可读,但是这里集合只有一个描述符,所以就不用判断了
	return(select(fd+1, &rset, NULL, NULL, &tv));
		/* 4> 0 if descriptor is readable */
}

使用 SO_RCVTIMEO 套接字选项为 recvfrom 设置超时

    该操作设置一次即可，与套接字的读操作绑定，前面的方法都需要循环重新设置，
    本套接字选项仅适用于读操作，类似的 SO_SNDTIMEO 选项对应于写操作，两者均不能用于 connect 设置超时

void dg_cli(FILE *fp, int sockfd, const SA *pservaddr, socklen_t servlen)
{
	int			n;
	char			sendline[MAXLINE], recvline[MAXLINE + 1];
	struct timeval	tv;
    // 指向 timeval 结构体的指针，保存的是超时的值
	tv.tv_sec = 5;
	tv.tv_usec = 0;
	Setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));

	while (Fgets(sendline, MAXLINE, fp) != NULL) {
		Sendto(sockfd, sendline, strlen(sendline), 0, pservaddr, servlen);
		n = recvfrom(sockfd, recvline, MAXLINE, 0, NULL, NULL);
		if (n < 0) {
            // I/O 超时操作，recvfrom 函数返回一个 EWOULDBLOCK 错误
			if (errno == EWOULDBLOCK) {
				fprintf(stderr, "socket timeout\n");
				continue;
			} else
				err_sys("recvfrom error");
		}
		recvline[n] = 0;	/* null terminate */
		Fputs(recvline, stdout);
	}
}

14.3 recv 和 send 函数

    类似于 read 和 write 函数，不过多一个参数 flags

#include<sys/socket.h>
ssize_t recv(int sockfd, void* buff, size_t nbytes, int flags);
ssize_t send(int sockfd, const void* buff, size_t nbytes, int flags);
// 返回：成功返回读入写出的字节数，出错返回 -1

    flag 可以用来标识一些操作，绕过路由表查找、仅本操作非阻塞、发送或接受外带数据、窥看外来消息、等待所有数据。
    flag 是值传递，并不是值-结果参数。所以它只能从进程向内核传递标志，内核不能返回标志。
        随着协议的增加，有时候需要值-结果参数(内核向进程返回错误消息), 这个操作被融入到 recvmsg 和 sendmsg 中用 msghdr

14.4 readv 和 writev 函数

    这两个函数类似 read 和 write，不过 readv 和 writev 允许单个系统调用读入或写出自一个或者多个缓冲区。这些操作被称为分散读和集中写，因为来自读操作的输入数据被分散到多个应用缓冲区中，而来自多个应用缓冲区的输出数据被集中提供给单个写操作。

#include<sys/uio.h>
ssize_t readv(int fileds, const struct iovec* iov, int iovcnt);
ssize_t writev(int fields, const struct iovec* iov, int iovcnt);
// 返回：成功返回读入或写出的字节数，出错返回 -1
struct iovec{
    void *iov_base;      // buf 的开始地址
    size_t iov_len;      // buf 的大小
}

    struct iovec 结构体定义如上，函数第二个参数指向的是一个 iovec 的数组，一般系统中定义数组长度的常值为 16，最大值一般在 1024~2100
    readv 和 writev 函数可用于任何描述符，不仅仅局限于套接字描述符。writev 是一个原子操作，所以对于 UDP 来说，一次 writev 仅产生一个 UDP 数据报
    当一个 4 字节的 write 和 396 字节的 write 调用时可能会触发 naggle 算法合并它们，解决这个问题的首选方法就是针对这两个缓冲区调用 writev 函数

14.5 recvmsg 和 sendmsg 函数

    这两个函数是最通用的 I/O 函数，可以替换上面所有的读写函数

#include<sys/socket.h>
ssize_t recvmsg(int sockfd, struct msghdr * msg, int flags);
ssize_t sendmsg(int sockfd, struct msghdr * msg, int flags);
// 返回：成功读入或者写出的字节数，出错则为 -1
struct msghdr{   // 用来保存大部分参数
    void *msg_name;
    socklen_t msg_namelen;
    struct iovec *msg_iov;
    int msg_iovlen;
    void *msg_control;
    socklen_t msg_controllen;
    int msg_flags;
}

        mag_name 和 msg_namelen 这两个成员用于套接字未连接的场合(UDP 等)，msg_name 指向一个套接字地址结构，在其中存放接受者(sendmsg)或者发送者(recvmsg)的协议地址。
        如果无需指明协议地址，msg_name 是空指针。msg_namelen 对于 sendmsg 是值参数，对于 recvmsg 是值-结果参数。
        msg_iov 和 msg_iovlen 这两个成员指定输入或输出缓冲区数组（就是 iovec 数组, 在上一小节中定义）
        msg_control和 msg_controllen 这两个成员指定可选的辅助数据的位置和大小 msg_controllen 对于 recvmsg 来说是一个值-结果参数
        对于 recvmsg 和 sendmsg 需要区别他们的两个标志变量，一个是传递值的 flags 参数，另一个是所传递 msghdr 结构的 msg_flags 成员，传递的是引用，因为传递给函数的是地址
        只有 recvmsg 使用 msg_flags 参数。recvmsg被调用时, flags参数被复制到msg_flags成员,并由内核使用其值驱动接受处理过程. 内核依旧使用recvmsg的结果更新msg_flags
        sendmsg 忽略该参数，它直接使用flag参数驱动发送过程

    UDP套接字调用recvmsg时的数据结构
        协议地址分配空间为16字节, 辅助数据分配空间为20字节
        缓冲区初始化分配空间为3个iovec结构组成的数组
            第一个为100字节的缓冲区
            第二个为60字节的缓冲区
            第三个为80字节的缓冲区
        msg_flags是由函数内部copy flags过去的,所以这里为空

recvmsg返回时的更新

    recvmsg返回时的更新
        由msg_name成员指向缓冲区被一个网际套接字地址结构填充,其为收到数据报的源IP和UDP源端口
        msg_namelen成员(值-结果参数)被更新为网络套接字地址结构的长度,但是这里无变化,本来就是16字节
        所接受数据报的前70字节存放在第一个缓冲区中,中60字节存放在第二个缓冲区中, 后10字节存放在第三个缓冲区中,第三个缓冲区的最后70字节无变化(recvmsg函数的返回值,即170,就是该数据报的大小)
        由msg_control成员指向缓冲区被填充了一个cmsghdr结构.
            该结构的cmsg_len成员值为16
            该结构的cmsg_level成员值为IPPROTO_IP
            该结构的cmsg_type成员值为IP_RECVDSTADDR
            随后4字节存放所收到的UDP数据报的目的IP地址,
            这20字节的缓冲区的后4字节没有动

14.6 辅助数据

    辅助数据可通过调用 sendmsg 和 recvmsg 这两个函数，使用 msghdr 结构中的 msg_control 和 msg_controllen 这两个成员来发送和接收，也叫做控制信息。
    辅助数据由一个或多个辅助数据对象构成，每个对象以一个定义在头文件<sys/socket.h>中的 cmsghdr 结构体

    struct cmsghdr{
    	socklen_t cmsg_len;
    	int cmsg_level;
    	int cmsg_type;
    }

14.7 排队的数据量

        有时候我们想要在不真正读取数据的前提下知道一个套接字上已有多少数据排队等待着读取。

    有三种技术可以获得一排队数据量。
        如果获取排队数据量的目的在于避免读操作内核阻塞，那么可以使用非阻塞式 I/O，但是不能获得数据量，只能直到是否有数据。
        如果我们既想查看数据又想数据留在接收队列中等待其余部分的读取，使用 MSG_PEEK 标志。
            如果我们想这么做,但是不知道是否真的额有数据可读:
                可以使用非阻塞套接字来实现既能判断是否有数据可读，然后又可以查看数据但不读取(MSG_PEEK)。
                需要注意的是对于 TCP 连接，两次获取量的值大小可能不同，如果在两次获取之间收到了流数据。
                但是 UDP 仅返回第一个数据报的大小，所以即使两次之间有新的数据报，也不影响
        一些实现支持 ioctl 的 FIONREAD 命令。该命令的第三个 ioctl 参数是指向某个整数的一个指针，内核通过该整数返回的值就是套接字接收队列的当前字节数。
        该值是已排队字节的总和，对于 UDP 包括所有已排队的数据报。某些实现中，对 UDP 套接字返回的值还包括一个套接字地址结构的空间，其中含有发送者的 IP 地址和端口号

14.8 套接字和标准 I/O

    执行 I/O 还可以使用标准 I/O 函数库，使用标准 I/O 对套接字进行读取一般可以打开两个流，一个用来读，一个用来写。
    不建议在套接字上使用标准 I/O

小结

    在套接字操作上设置时间限制的方法有三个：
        使用 alarm 函数和 SIGALRM 信号。
        使用由 select 提供的时间限制
        使用较新的 SO_RCVTIMEO 和 SO_SNDTIMEO 套接字选项
    第一种方法简单易用，但是涉及信号处理，可能引发竞争条件。使用 select 会阻塞在 select 上，而不是阻塞在 read，write，connect 调用上。第三种方法不是所有系统都提供。
    recvmsg 和 sendmsg 是 5 组读写函数中最通用的。它有其余读写函数的所有特性：指定 MSG_xxx，返回或指定对端的协议地址，使用多个缓冲区，还增加了两个新特性：给应用进程返回标志，接收或者发送辅助数据。
    C 标准 I/O 可以用在套接字上，但是并不推荐使用。

